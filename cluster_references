Explicit calls:

./maptree : library(cluster)

./VR/MASS/inst/scripts/ch11.R

./e1071/R/bclust.R:  if method== "diana" : if (!require("cluster")) stop("...")

./pamr/	  : require(cluster)  -- but should really  require(mva) !!!

---------------

./cclust/R/cclust.R:    cluster <- integer(xrows)
./cclust/R/cclust.R:                   cluster = as.integer(cluster),
./cclust/R/cclust.R:                   cluster = as.integer(cluster),
./cclust/R/cclust.R:                   cluster = as.integer(cluster),
./cclust/R/cclust.R:    cluster <- retval$cluster + 1
./cclust/R/cclust.R:    cluster <- cluster[order(perm)]
./cclust/R/cclust.R:      x <- (x - clobj$centers[clobj$cluster, ])^2
./cclust/R/cclust.R:        retval[k] <- sum(x[clobj$cluster==k,])
./cclust/R/cclust.R:    within <- withinss(list(centers = centers, cluster = cluster), xold)
./cclust/R/cclust.R:        ncenters = ncenters, cluster = cluster, size = retval$clustersize,
./cclust/R/cclust.R:  cluster <- integer(xrows)
./cclust/R/cclust.R:    stop("Number of variables in cluster object and x are not the same!")
./cclust/R/cclust.R:               cluster = as.integer(cluster),
./cclust/R/cclust.R:  clobj$cluster <- retval$cluster+1
./cclust/R/Rindexes.R:      x <- (x - clobj$centers[clobj$cluster, ])^2
./cclust/R/Rindexes.R:        retval[k] <- sum(x[clobj$cluster==k,])
./cclust/R/Rindexes.R:    varwithinss <- function(x, centers, cluster)
./cclust/R/Rindexes.R:        x <- (x - centers[cluster, ])^2
./cclust/R/Rindexes.R:            varwithins[k,l] <- sum(x[cluster==k,l])
./cclust/R/Rindexes.R:    ttww <- function(x, clsize, cluster)
./cclust/R/Rindexes.R:          w<- w+cov(x[cluster==l,])*clsize[l]
./cclust/R/Rindexes.R:    db <- function(withins, centers, cluster)
./cclust/R/Rindexes.R:        mse <- withins/table(cluster)
./cclust/R/Rindexes.R:    likelihood <- function (x, centers, cluster)
./cclust/R/Rindexes.R:          l <- l - log(prod(x[i,]*centers[cluster[i],] +
./cclust/R/Rindexes.R:                            (1-x[i,])*(1-centers[cluster[i],])))
./cclust/R/Rindexes.R:    ##withins <- withinss1(x, centers, cluster)
./cclust/R/Rindexes.R:    ## varwithins <- varwithinss(x, clres$centers, clres$cluster)
./cclust/R/Rindexes.R:    zttw <- ttww(x, clres$size, clres$cluster)
./cclust/R/Rindexes.R:      vecallindex[3] <- db(clres$withins, clres$centers, clres$cluster)
./cclust/R/Rindexes.R:        varwithins <- varwithinss(x, clres$centers, clres$cluster)
./cclust/R/Rindexes.R:       vecallindex[14] <- likelihood(x,clres$centers, clres$cluster)
./cclust/man/cclust.Rd:\item{centers}{Number of clusters or initial values for cluster centers}
./cclust/man/cclust.Rd:  If \code{centers} is a matrix, its rows are taken as the initial cluster
./cclust/man/cclust.Rd:  The algorithm stops, if no cluster center has changed during the last
./cclust/man/cclust.Rd:  of cluster indices which have changed since the last iteration is given.
./cclust/man/cclust.Rd:  If \code{dist} is \code{"euclidean"}, the distance between the cluster center
./cclust/man/cclust.Rd:  cluster center and the data points is the sum of the absolute values
./cclust/man/cclust.Rd:  method, which works by repeatedly moving all cluster centers
./cclust/man/cclust.Rd:  data for which a particular cluster has benn the winner so far.
./cclust/man/cclust.Rd:  \item{centers}{The final cluster centers.}
./cclust/man/cclust.Rd:  \item{initcenters}{The initial cluster centers.}
./cclust/man/cclust.Rd:  \item{cluster}{Vector containing the indices of the clusters where
./cclust/man/cclust.Rd:  \item{size}{The number of data points in each cluster.}
./cclust/man/cclust.Rd:plot(x, col=cl$cluster)
./cclust/man/cclust.Rd:plot(x, col=cl$cluster)
./cclust/man/cclust.Rd:         plot(y, col=ycl$cluster)
./cclust/man/cclust.Rd:\keyword{cluster}
./cclust/man/predict.cclust.Rd:  Assigns each data point (row in \code{newdata}) the cluster corresponding to
./cclust/man/predict.cclust.Rd:  \item{cluster}{Vector containing the indices of the clusters where
./cclust/man/predict.cclust.Rd:  \item{size}{The number of data points in each cluster.}
./cclust/man/predict.cclust.Rd:plot(x, col=cl$cluster)
./cclust/man/predict.cclust.Rd:plot(x, col=cl$cluster)
./cclust/man/predict.cclust.Rd:plot(y, col=ycl$cluster)
./cclust/man/predict.cclust.Rd:\keyword{cluster}
./cclust/man/Rindexes.Rd:    dispersion of the data points in a cluster and between the clusters
./cclust/man/Rindexes.Rd:    	\eqn{B} is the scatter matrix of the cluster centers.
./cclust/man/Rindexes.Rd:    	then while the C-Index is a cluster
./cclust/man/Rindexes.Rd:    	is the sum of all \eqn{n_{(d)}} within cluster distances,
./cclust/man/Rindexes.Rd:    	independence of the variables within a cluster, a cluster solution
./cclust/man/Rindexes.Rd:    	can be regarded as a mixture model for the data, where the cluster
./cclust/man/Rindexes.Rd:    	used as a quantity measure for a cluster solution. Note that the
./cclust/man/Rindexes.Rd:    	deviation of a variable in the cluster centers compared to its
./cclust/man/Rindexes.Rd:\keyword{cluster}
./cclust/src/cclust.c:	   double *centers, int *cluster, int *clustersize,
./cclust/src/cclust.c:	cluster[k] = m;
./cclust/src/cclust.c:    clustersize[cluster[k]]++;
./cclust/src/cclust.c:	  double *centers, int *cluster, int *clustersize,
./cclust/src/cclust.c:  /* Initialize cluster size and centers with 0 */
./cclust/src/cclust.c:	clustersize[cluster[k]]++; */
./cclust/src/cclust.c:	centers[cluster[k]+(*ncenters)*m] += x[k+(*xrows)*m];
./cclust/src/cclust.c:		if(cluster[l]==k){
./cclust/src/cclust.c:	  double *centers, int *cluster,
./cclust/src/cclust.c:      if(cluster[m] != clustnew[m]){
./cclust/src/cclust.c:	cluster[m] = clustnew[m];
./cclust/src/cclust.c:	   double *centers, int *cluster, int *clustersize,
./cclust/src/cclust.c:	cluster[k] = m;
./cclust/src/cclust.c:    t[cluster[k]]=t[cluster[k]]+1;
./cclust/src/cclust.c:    centers[cluster[k]+(*ncenters)*n]+=(1.0/pow(t[cluster[k]],par1))*(x[k+(*xrows)*n]-centers[cluster[k]+(*ncenters)*n]);
./cclust/src/cclust.c:  centers[cluster[k]+(*ncenters)*n]+=e*(x[k+(*xrows)*n]-centers[cluster[k]+(*ncenters)*n]);
./cclust/src/cclust.c:      if (cluster[k]==m){
./cclust/src/cclust.c:	     double *centers, int *cluster,
./cclust/src/cclust.c:      oncent(xrows, xcols, x, ncenters, centers, cluster, clustersize,
./cclust/src/cclust.c:     clustersize[cluster[k]]++;
./cclust/src/cclust.c:	   double *centers, int *cluster, int *clustersize,
./cclust/src/cclust.c:      cluster[k] = minn;
./cclust/src/cclust.c:      if (cluster[k]==m){
./cclust/src/cclust.c:	     double *centers, int *cluster,int *itermax, int *iter,
./cclust/src/cclust.c:    oncentb(xrows, xcols, x, ncenters, centers, cluster, clustersize,
./cclust/src/cclust.c:  clustersize[cluster[k]]++;
./cclust/src/cclust.c:  /*printf("size%d\n...cluster%d\n",clustersize[cluster[k]],cluster[k]);*/
Übereinstimmungen in Binärdatei ./cclust/src/cclust.o.
Übereinstimmungen in Binärdatei ./cclust/src/cclust.so.
./multiv/R/hierclust.R:# go right through.  Check out the cluster criterion values reported on in the
./multiv/R/hierclust.R:# the variance component on the prinipal axis of the cluster, and thereby
./multiv/R/hierclust.R:# redefines the cluster criterion such that linear clusters are preferred.  A
./multiv/R/hierclust.R:  iklass               <- matrix(0.0, n, n) # Will store cluster assgmnts.
./multiv/R/hierclust.R:  membr                <- double(n)         # Singleton, cluster cardinalities
./multiv/R/hierclust.R:  classx               <- 0                 # X-values corresp. to a cluster
./multiv/R/hierclust.R:  classy               <- 0                 # Y-values corresp. to a cluster
./multiv/R/hierclust.R:#      gncm: Get new cluster memberships
./multiv/R/members.R:# Return with cluster assignments at all levels of the hierarchy
./multiv/R/partition.R:#          or (ii) `g' is set of initial guesses for the cluster centers.
./multiv/R/partition.R:#          Resequence the cluster nos.
./multiv/R/partition.R:           cat("Cluster centers (displayed horizontally for each cluster):",
./multiv/man/bea.Rd:\keyword{cluster}
./multiv/man/hierclust.Rd:  a cluster.  Agglomerates the next closest pair of observations or clusters.
./multiv/man/hierclust.Rd:recommend: On the first occasion, go right through.  Check out the cluster
./multiv/man/hierclust.Rd:the variance component on the principal axis of the cluster, and thereby
./multiv/man/hierclust.Rd:redefines the cluster criterion such that linear clusters are preferred.  A
./multiv/man/hierclust.Rd:was with the cluster formed at the (earlier) stage \code{j} of the algorithm. Thus
./multiv/man/hierclust.Rd:in the sense that a cluster plot using this ordering and matrix \code{merge} will
./multiv/man/hierclust.Rd:In hierarchical cluster displays, a decision is needed at each merge to
./multiv/man/hierclust.Rd:orderings for the leaves in a cluster tree, or dendrogram.  The default
./multiv/man/hierclust.Rd:algorithm in \code{hc} is to order the subtree so that the tighter cluster is on
./multiv/man/hierclust.Rd:\keyword{cluster}
./multiv/man/members.Rd:in function `hierclust' or `hclust', determine cluster assignments of all
./multiv/man/members.Rd:matrix of dimensions \code{n} by \code{n-2} giving cluster assignments to the 2, 3, \dots{}
./multiv/man/members.Rd:n-1 cluster partitions of the hierarchy.  This corresponds to levels \code{n-2}
./multiv/man/members.Rd:two cluster sequence numbers.
./multiv/man/members.Rd:\keyword{cluster}
./multiv/man/partition.Rd:  Returns cluster memberships.  In the case of a data matrix, the user
./multiv/man/partition.Rd:clusters as there are rows in an initial guess at the cluster centers.
./multiv/man/partition.Rd:matrix of initial guesses for the cluster centers.  Each row represents a
./multiv/man/partition.Rd:cluster center, and thus \code{centers} must have the same number of columns as
./multiv/man/partition.Rd:FALSE (default) implies that cluster cardinalities, cluster center coordinates,
./multiv/man/partition.Rd:and cluster compactness values will not be output to the command window.
./multiv/man/partition.Rd:in the case of the Hartigan algorithm (where initial cluster centers
./multiv/man/partition.Rd:\item{cluster}{
./multiv/man/partition.Rd:straightforward: a slice is made, orthogonal to the cluster criterion value
./multiv/man/partition.Rd:# Secondly, specifying guesses at cluster centers.
./multiv/man/partition.Rd:text(iris[!wrong, 2], iris[!wrong, 3], km$cluster)
./multiv/man/partition.Rd:# identify cluster membership that is correct
./multiv/man/partition.Rd:\keyword{cluster}
./multiv/src/hc.f:C                    cluster cardinalities, current nearest  C
./multiv/src/hc.f:C  Update dissimilarities from new cluster.
./multiv/src/hc.f:C                   cluster cardinalities, nearest neighbour     C
./multiv/src/hc.f:C  Determine next agglomerable object/cluster.
./multiv/src/hc.f:C   cluster assignments at all levels, at extra comput. expense C
./multiv/src/hcmovie.f:C  DAT2(N*M)         copy of part of DATA (i.e. rows corresp. to a cluster).
./multiv/src/hcmovie.f:C                    the seq. no. of a cluster is the smaller seq. no. of the
./multiv/src/hcmovie.f:C                    With this notation, a test for a non-singleton cluster
./multiv/src/hcmovie.f:C                    is: a cluster seq. no. must additionally exist at a lower
./multiv/src/hcmovie.f:C  MEMBR             vector of length N, used to store cluster cardinalities;
./multiv/src/hcmovie.f:C                    refers to a singleton cluster.  MEMBR is a real vector,
./multiv/src/hcmovie.f:C                    and to non-singleton cluster, FLAG is necessary.
./multiv/src/hcmovie.f:C                    present (resp. absent) in cluster i.
./multiv/src/hcmovie.f:C  POTCL             potential cluster: N-length vector of 1s and 0s.
./multiv/src/hcmovie.f:C  CENTR(M)          vector of centers of a cluster, used by PRCOAN.
./multiv/src/hcmovie.f:C  GNCM    Get new cluster memberships
./multiv/src/hcmovie.f:C-- Variances of a potential 2-member cluster:
./multiv/src/hcmovie.f:C-- Variances of a cluster with potentially > 2 members:
./multiv/src/hcmovie.f:C-- Variances of a potential 2-member cluster:
./multiv/src/hcmovie.f:C-- Variances of a cluster with potentially > 2 members:
./multiv/src/hcmovie.f:C  Update cluster memberships array, iklass
./multiv/src/hcmovie.f:C     cluster, then we must pick up the most recently updated row of array
./multiv/src/hcmovie.f:C     IKLASS.  1 and 0 values in this row indicate memberships in the cluster.
./multiv/src/hcmovie.f:C     a non-singleton cluster.
./multiv/src/hcmovie.f:C        Non-singleton, i.e. multi-object cluster
./multiv/src/hcmovie.f:C        Non-singleton cluster
./multiv/src/hcmovie.f:C     Given the seq. no. (identifier) of a non-singleton cluster, find where
./multiv/src/hcmovie.f:C     cluster's members.
./multiv/src/hcmovie.f:C     ICL is the cluster seq. no., ILAGG is the value sought, and
./multiv/src/members.f:C  ICLASS:       array of cluster assignments; dim. N by LEV.   C
./multiv/src/members.f:c           Because it is -ve, iia(i) is a seq. no. of a cluster.
./multiv/src/members.f:c           Find this cluster, and get the lowest seq. no. of obs. in it.
./multiv/README.orig:2. Hierarchical cluster analysis
./multiv/README.orig:          members.q          [Determine cluster assignments from hierarchy.]
./multiv/README.orig:          specifies a desired degree of cluster ellipticity.  A "movie" or
./multiv/README.orig:          initial guesses of the cluster centers on starting, and which is
./mda/R/mda.q:			wmj <- diag(nc)[TT$cluster,  ]
./mda/R/mda.R:            wmj <- diag(nc)[TT$cluster, ]
./gee/R/ugee.R:        cat("\nMaximum cluster size   : ", x$max.id, "\n")
./gee/man/gee.Rd:  so that observations on a cluster are contiguous rows for all entities
./gee/man/gee.Rd:  a square matrix of dimension maximum cluster size containing the user
./gee/man/gee.Rd:  same value of \code{id} as members of the same cluster.  Thus it
./gee/src/ugee.c:        	/* printf("cluster %d g\n",i); */
./gee/tests/tests.Rout.save:Maximum cluster size   :  20

./cluster/

./ptproc/man/cond-int.Rd:  cluster model with a Laguerre-type polynomial as the trigger
./ptproc/man/penalty.Rd:## Construct a K = 3 Hawkes cluster model
./survival4/man/cluster.Rd:\name{cluster}
./survival4/man/cluster.Rd:cluster(x)
./survival4/man/cluster.Rd:  cluster indicator.
./survival4/man/cluster.Rd:coxph(Surv(futime, fustat) ~ age + cluster(group))
./survival4/man/coxph.Rd:model includes a cluster() operative, FALSE otherwise.
./survival4/Changelog:Cox models with the cluster() argument, and to the printout.
./survival4/Readme:   * can handle correlated error Cox models, by adding a simple "cluster()"
./survival4/INDEX:cluster 	 Identify clusters.
./survival4/Examples/Rtest.out.supplied:+                  cluster(id), bladder, method='breslow')
./survival4/Examples/Rtest.out.supplied:    cluster(id), data = bladder, method = "breslow")
./survival4/Examples/Rtest.out.supplied:> fita <- coxph(Surv(start, stop, event) ~ rx + size + number + cluster(id),
./survival4/Examples/Rtest.out.supplied:    cluster(id), data = bladder2, method = "breslow")
./survival4/Examples/Testlog:	    doovarian.s  added a test that robust=T and cluster() give the
./survival4/Examples/fit.bladder.s:		 cluster(id), bladder, method='breslow')
./survival4/Examples/fit.bladder.s:fita <- coxph(Surv(start, stop, event) ~ rx + size + number + cluster(id),
./survival4/Examples/Rtest:                 cluster(id), bladder, method='breslow')
./survival4/Examples/Rtest:fita <- coxph(Surv(start, stop, event) ~ rx + size + number + cluster(id),
./survival4/Examples/Rtest.out:+                  cluster(id), bladder, method='breslow')
./survival4/Examples/Rtest.out:    cluster(id), data = bladder, method = "breslow")
./survival4/Examples/Rtest.out:> fita <- coxph(Surv(start, stop, event) ~ rx + size + number + cluster(id),
./survival4/Examples/Rtest.out:    cluster(id), data = bladder2, method = "breslow")
./survival4/R/newsurvival.R:#SCCS @(#)cluster.s	4.1 10/01/94
./survival4/R/newsurvival.R:cluster <- function(x) x
./survival4/R/newsurvival.R:	    dropx <- untangle.specials(Terms, 'cluster')$terms
./survival4/R/newsurvival.R:###    Terms <- if(missing(data)) terms(formula, c('strata', 'cluster'))
./survival4/R/newsurvival.R:###	     else     terms(formula, c('strata', 'cluster'),data=data)
./survival4/R/newsurvival.R:    Terms <- terms(formula, c('strata', 'cluster'))
./survival4/R/newsurvival.R:    cluster<- attr(Terms, "specials")$cluster
./survival4/R/newsurvival.R:    if (length(cluster)) {
./survival4/R/newsurvival.R:	cluster <- strata(m[,tempc$vars], shortlabel=T)  #allow multiples
./survival4/R/newsurvival.R:###<TSL> drop strata/cluster terms from the formula.
./survival4/R/newsurvival.R:	    if (length(cluster)) {
./survival4/R/newsurvival.R:		temp <- residuals.coxph(fit2, type='dfbeta', collapse=cluster,
./survival4/R/newsurvival.R:		indx <- match(cluster, unique(cluster))
./survival5/R/summary.coxph.s:	  "assume independence of\n     observations within a cluster,",
./survival5/R/predict.coxph.s:    if (length(attr(Terms, 'specials')$cluster)) {
./survival5/R/predict.coxph.s:	temp <- untangle.specials(Terms, 'cluster', 1)
./survival5/R/coxph.s:    special <- c("strata", "cluster")
./survival5/R/coxph.s:    cluster<- attr(Terms, "specials")$cluster
./survival5/R/coxph.s:    if (length(cluster)) {
./survival5/R/coxph.s:	cluster <- strata(m[,tempc$vars], shortlabel=T)  #allow multiples
./survival5/R/coxph.s:	    if (length(cluster)) {
./survival5/R/coxph.s:		temp <- residuals.coxph(fit2, type='dfbeta', collapse=cluster,
./survival5/R/coxph.s:		temp0 <- residuals.coxph(fit2, type='score', collapse=cluster,
./survival5/R/survfit.coxph.s:    cluster<-attr(Terms, "specials")$cluster
./survival5/R/survfit.coxph.s:    if (length(cluster)) {
./survival5/R/survfit.coxph.s:	temp <- untangle.specials(Terms, 'cluster')
./survival5/R/survfit.coxph.s:    #  (The coxph.getdata routine never returns cluster() terms).
./survival5/R/survreg.s:    special <- c("strata", "cluster")
./survival5/R/survreg.s:    cluster<- attr(Terms, "specials")$cluster
./survival5/R/survreg.s:    if (length(cluster)) {
./survival5/R/survreg.s:        cluster <- strata(m[,tempc$vars], shortlabel=T)  #allow multiples
./survival5/R/coxph.getdata.s:	    dropx <- untangle.specials(Terms, 'cluster')$terms
./survival5/R/cluster.s:#SCCS @(#)cluster.s	4.1 10/01/94
./survival5/R/cluster.s:cluster <- function(x) x
./survival5/man/coxph.Rd:model includes a \code{cluster()} operative, \code{FALSE} otherwise.
./survival5/man/coxph.Rd:The \code{cluster} term is used to compute a robust variance for the model.
./survival5/man/coxph.Rd:The term \code{+ cluster(id)}, where \code{id == unique(id)}, is equivalent to
./survival5/man/coxph.Rd:\link{\code{cluster}}, \link{\code{survfit}}, \link{\code{Surv}}, \link{\code{strata}},\link{\code{ridge}}, \link{\code{pspline}},\link{\code{frailty}}.
./survival5/man/cluster.Rd:\name{cluster}
./survival5/man/cluster.Rd:\alias{cluster}
./survival5/man/cluster.Rd:cluster(x)
./survival5/man/cluster.Rd:cluster indicator.
./survival5/man/cluster.Rd:coxph(Surv(futime, fustat) ~ age + cluster(group), data = ovarian)
./survival5/Changelog:contained a cluster() statement -- it was trying to create a column for this
./survival5/Changelog:and of course the X matrix doesn't have one; cluster() only effects variance
./survival5/Changelog:estimation.  Predict now ignores "cluster" terms.
./survival5/Examples/test/Rtest:		 cluster(id), bladder, method='breslow')
./survival5/Examples/test/Rtest:fita <- coxph(Surv(start, stop, event) ~ rx + size + number + cluster(id),
./survival5/Examples/test/Rtest.out:+ 		 cluster(id), bladder, method='breslow')
./survival5/Examples/test/Rtest.out:    cluster(id), data = bladder, method = "breslow")
./survival5/Examples/test/Rtest.out:> fita <- coxph(Surv(start, stop, event) ~ rx + size + number + cluster(id),
./survival5/Examples/test/Rtest.out:    cluster(id), data = bladder2, method = "breslow")
./survival5/Examples/test/testall.save:+ 		 cluster(id), bladder, method="breslow")
./survival5/Examples/test/testall.save:	cluster(id), data = bladder, method = "breslow")
./survival5/Examples/test/testall.save:> fita <- coxph(Surv(start, stop, event) ~ rx + size + number + cluster(id),
./survival5/Examples/test/testall.save:coxph(formula = Surv(start, stop, event) ~ rx + size + number + cluster(id),
./survival5/Examples/test/fit.bladder.s:		 cluster(id), bladder, method='breslow')
./survival5/Examples/test/fit.bladder.s:fita <- coxph(Surv(start, stop, event) ~ rx + size + number + cluster(id),
./survival5/Examples/test/Testlog:	    doovarian.s  added a test that robust=T and cluster() give the
./survival5/Examples/test/Rtest.out.save:+ 		 cluster(id), bladder, method='breslow')
./survival5/Examples/test/Rtest.out.save:    cluster(id), data = bladder, method = "breslow")
./survival5/Examples/test/Rtest.out.save:> fita <- coxph(Surv(start, stop, event) ~ rx + size + number + cluster(id),
./survival5/Examples/test/Rtest.out.save:    cluster(id), data = bladder2, method = "breslow")
./survival5/Examples/testfrail/colon.s:fitc1 <- coxph(Surv(time, status) ~ rx + extent + node4 + cluster(id)
./survival5/Examples/testfrail/colon.s:fitc5 <- coxph(Surv(time, status) ~ rx + extent + node4 +cluster(id)
./survival5/Examples/testfrail/rat2.s:r2fit0 <- coxph(Surv(start, stop, status) ~ rx + cluster(id), rat2)
./survival5/Examples/testfrail/testall.save:> fitc1 <- coxph(Surv(time, status) ~ rx + extent + node4 + cluster(id)
./survival5/Examples/testfrail/testall.save:coxph(formula = Surv(time, status) ~ rx + extent + node4 + cluster(id) + strata(
./survival5/Examples/testfrail/testall.save:> fitc5 <- coxph(Surv(time, status) ~ rx + extent + node4 +cluster(id)
./survival5/Examples/testfrail/testall.save:> > r2fit0 <- coxph(Surv(start, stop, status) ~ rx + cluster(id), rat2)
./survival5/Examples/testfrail/testall.save:coxph(formula = Surv(start, stop, status) ~ rx + cluster(id), data = rat2)
./survival5/Examples/testfrail/Rtest:fitc1 <- coxph(Surv(time, status) ~ rx + extent + node4 + cluster(id)
./survival5/Examples/testfrail/Rtest:fitc5 <- coxph(Surv(time, status) ~ rx + extent + node4 +cluster(id)
./survival5/Examples/testfrail/Rtest:r2fit0 <- coxph(Surv(start, stop, status) ~ rx + cluster(id), rat2)
./survival5/Examples/testfrail/Rtest.out.save:> fitc1 <- coxph(Surv(time, status) ~ rx + extent + node4 + cluster(id)
./survival5/Examples/testfrail/Rtest.out.save:coxph(formula = Surv(time, status) ~ rx + extent + node4 + cluster(id) +
./survival5/Examples/testfrail/Rtest.out.save:> fitc5 <- coxph(Surv(time, status) ~ rx + extent + node4 +cluster(id)
./survival5/Examples/testfrail/Rtest.out.save:> r2fit0 <- coxph(Surv(start, stop, status) ~ rx + cluster(id), rat2)
./survival5/Examples/testfrail/Rtest.out.save:coxph(formula = Surv(start, stop, status) ~ rx + cluster(id),
./survival5/Examples/testfrail/Rtest.out:> fitc1 <- coxph(Surv(time, status) ~ rx + extent + node4 + cluster(id)
./survival5/Examples/testfrail/Rtest.out:coxph(formula = Surv(time, status) ~ rx + extent + node4 + cluster(id) +
./survival5/Examples/testfrail/Rtest.out:> fitc5 <- coxph(Surv(time, status) ~ rx + extent + node4 +cluster(id)
./survival5/Examples/testfrail/Rtest.out:> r2fit0 <- coxph(Surv(start, stop, status) ~ rx + cluster(id), rat2)
./survival5/Examples/testfrail/Rtest.out:coxph(formula = Surv(start, stop, status) ~ rx + cluster(id),
./survival5/INDEX:cluster 	 Identify clusters.
./Matrix/src/lapackd.h:    // A = Q*T*Q**T, so that a selected cluster of eigenvalues appears
./maptree/R/maptree.R:# draw.clust <- function (cluster, cex=par("cex"),
./maptree/R/maptree.R:# group.clust <- function (cluster, k=NULL, h=NULL)
./maptree/R/maptree.R:# kgs <- function (cluster, diss, alpha=1, maxclust=NULL)
./maptree/R/maptree.R:# prune.clust <- function (cluster, k=NULL, h=NULL)
./maptree/R/maptree.R:draw.clust <- function (cluster, cex=par("cex"),
./maptree/R/maptree.R:  # cluster is class hclust or twins
./maptree/R/maptree.R:  # cases are names for cluster objects
./maptree/R/maptree.R:  if (class (cluster) == "hclust") clust <- cluster
./maptree/R/maptree.R:  else if (inherits (cluster, "twins"))
./maptree/R/maptree.R:    clust <- as.hclust (cluster)
./maptree/R/maptree.R:group.clust <- function (cluster, k=NULL, h=NULL)
./maptree/R/maptree.R:  # cluster is class hclust or twins
./maptree/R/maptree.R:  if (is.null (h) && is.null (k)) return (cluster$order)
./maptree/R/maptree.R:  if (!is.null (h) && h > max (cluster$height))
./maptree/R/maptree.R:  if (!is.null (k) && (k == 1 || k > length (cluster$height)))
./maptree/R/maptree.R:  if (class (cluster) == "hclust") clust <- cluster
./maptree/R/maptree.R:  else if (inherits (cluster, "twins"))
./maptree/R/maptree.R:    clust <- as.hclust (cluster)
./maptree/R/maptree.R:kgs <- function (cluster, diss, alpha=1, maxclust=NULL)
./maptree/R/maptree.R:  # cluster is class hclust or twins
./maptree/R/maptree.R:  if (class(cluster) == "hclust") clust <- cluster
./maptree/R/maptree.R:  else if (inherits (cluster, "twins"))
./maptree/R/maptree.R:    clust <- as.hclust (cluster)
./maptree/R/maptree.R:prune.clust <- function (cluster, k=NULL, h=NULL)
./maptree/R/maptree.R:  # cluster is class hclust or twins
./maptree/R/maptree.R:  # returns pruned cluster
./maptree/R/maptree.R:  if (!is.null (h) && h > max (cluster$height))
./maptree/R/maptree.R:  if (!is.null (k) && (k == 1 || k > length (cluster$height)))
./maptree/R/maptree.R:  if (class (cluster) == "hclust") clust <- cluster
./maptree/R/maptree.R:  else if (inherits (cluster, "twins"))
./maptree/R/maptree.R:    clust <- as.hclust (cluster)
./maptree/man/draw.clust.Rd:  Graph a hierarchical cluster tree of class \code{twins}
./maptree/man/draw.clust.Rd:  draw.clust (cluster, cex=par("cex"), pch=par("pch"), size=2.5*cex,
./maptree/man/draw.clust.Rd:  \item{cluster}{object of class \code{hclust} or \code{twins}.}
./maptree/man/draw.clust.Rd:  \code{\link[cluster]{agnes}},
./maptree/man/draw.clust.Rd:  \code{\link[cluster]{diana}},
./maptree/man/draw.clust.Rd:  library (cluster)
./maptree/man/draw.clust.Rd:\keyword{cluster}
./maptree/man/group.clust.Rd:  group.clust (cluster, k=NULL, h=NULL)
./maptree/man/group.clust.Rd:  \item{cluster}{object of class \code{hclust} or \code{twins}.}
./maptree/man/group.clust.Rd:\value{Vector of pruned cluster membership}
./maptree/man/group.clust.Rd:  \code{\link[cluster]{twins.object}},
./maptree/man/group.clust.Rd:\keyword{cluster}
./maptree/man/map.groups.Rd:\keyword{cluster}
./maptree/man/prune.Rpart.Rd:\keyword{cluster}
./maptree/man/prune.clust.Rd:  Reduces a hierarchical cluster tree to a smaller tree either
./maptree/man/prune.clust.Rd:  prune.clust (cluster, k=NULL, h=NULL)
./maptree/man/prune.clust.Rd:  \item{cluster}{object of class \code{hclust} or \code{twins}.}
./maptree/man/prune.clust.Rd:\value{Pruned cluster object of class \code{hclust}.}
./maptree/man/prune.clust.Rd:  \code{\link[cluster]{twins.object}},
./maptree/man/prune.clust.Rd:  library (cluster)
./maptree/man/prune.clust.Rd:\keyword{cluster}
./maptree/man/kgs.Rd:  hierarchical cluster tree.
./maptree/man/kgs.Rd:  kgs (cluster, diss, alpha=1, maxclust=NULL)
./maptree/man/kgs.Rd:  \item{cluster}{object of class \code{hclust} or \code{twins}.}
./maptree/man/kgs.Rd:  where to prune a hierarchical cluster tree.  At any level of the
./maptree/man/kgs.Rd:  \code{\link[cluster]{twins.object}},
./maptree/man/kgs.Rd:  \code{\link[cluster]{dissimilarity.object}},
./maptree/man/kgs.Rd:  library (cluster)
./maptree/man/kgs.Rd:\keyword{cluster}
./maptree/inst/README:* new function kgs computes penalty measure for cluster trees.
./maptree/DESCRIPTION:Depends: R (>= 1.0), mva, cluster, rpart, combinat

./splancs/INDEX:pcp                     Fit a Poisson cluster process
./splancs/man/pcp.Rd:\title{Fit a Poisson cluster process}
./splancs/man/pcp.Rd:  The function fits a Poisson cluster process to point data for a given
./splancs/man/pcp.sim.Rd:  The function generates a Poisson cluster process for a given polygon within
./nlme0/R/lmList.R:  ##  in the original data are collapsed over the cluster variable by the
./nlme0/R/lme.R:  ##  in the original data are collapsed over the cluster variable by the
./permax/R/permax.R:         ig2=NULL, WHseed=NULL, cluster=NULL, stratify=FALSE, weights=NULL,
./permax/R/permax.R:         nl=50,nr=50,permute.cluster=FALSE,signed.rank=FALSE) {
./permax/R/permax.R:    if (!is.null(cluster)) cluster <- cluster[i2]
./permax/R/permax.R:  if (!is.null(cluster)) {
./permax/R/permax.R:    mclust <- table(cluster)
./permax/R/permax.R:    mct1 <- table(cluster,trt)[,1]
./permax/R/permax.R:    if (permute.cluster) {
./permax/R/permax.R:      if (stratify) stop('permute.cluster and stratify cannot both == TRUE')
./permax/R/permax.R:        stop('clusters cannot contain both groups when permute.cluster==TRUE')
./permax/R/permax.R:      o <- order(trt,cluster)
./permax/R/permax.R:      o <- order(cluster,trt)
./permax/R/permax.R:permsep <- function(data,ig1,nperm=0,ig2=NULL,WHseed=NULL, cluster=NULL, stratify=FALSE, permute.cluster=FALSE) {
./permax/R/permax.R:    if (!is.null(cluster)) cluster <- cluster[i2]
./permax/R/permax.R:  if (!is.null(cluster)) {
./permax/R/permax.R:    mclust <- table(cluster)
./permax/R/permax.R:    mct1 <- table(cluster,trt)[,1]
./permax/R/permax.R:    if (permute.cluster) {
./permax/R/permax.R:      if (stratify) stop('permute.cluster and stratify cannot both == TRUE')
./permax/R/permax.R:        stop('clusters cannot contain both groups when permute.cluster==TRUE')
./permax/R/permax.R:      o <- order(trt,cluster)
./permax/R/permax.R:      o <- order(cluster,trt)
./permax/R/permax.R:    cluster <- cluster[o]
./permax/R/permax.R:        min.np=1, WHseed=NULL, cluster=NULL, stratify=FALSE, weights=NULL,
./permax/R/permax.R:        permute.cluster=FALSE) {
./permax/R/permax.R:  if (!is.null(cluster)) {
./permax/R/permax.R:    o <- order(cluster)
./permax/R/permax.R:    mclust <- table(cluster)
./permax/R/permax.R:    if (permute.cluster) {
./permax/R/permax.R:      if (stratify) stop('permute.cluster and stratify cannot both == TRUE')
./permax/R/permax.R:      uv <- tapply(phen,cluster,min)
./permax/R/permax.R:      if (max(abs(tapply(phen,cluster,max)-uv))>0)
./permax/R/permax.R:        stop('clusters cannot contain both groups when permute.cluster==TRUE')
./permax/tests/test.R:# stratified on cluster, using ranks; equal weights
./permax/tests/test.R:# stratified on cluster, using ranks; average weighted by cluster sizes
./permax/tests/test.R:# correlations estimated within clusters; average weighted by cluster sizes
./permax/tests/test.Rout.save:    "seed.end"), cluster = clustind)
./permax/tests/test.Rout.save:> # stratified on cluster, using ranks; equal weights
./permax/tests/test.Rout.save:    "seed.end"), cluster = clustind, stratify = TRUE)
./permax/tests/test.Rout.save:> # stratified on cluster, using ranks; average weighted by cluster sizes
./permax/tests/test.Rout.save:    "seed.end"), cluster = clustind, stratify = TRUE, weights = table(clustind))
./permax/tests/test.Rout.save:    "seed.end"), cluster = clustind, stratify = TRUE, weights = table(clustind))
./permax/tests/test.Rout.save:    "seed.end"), cluster = clust2, permute.cluster = TRUE)
./permax/tests/test.Rout.save:    permute.cluster = TRUE)
./permax/tests/test.Rout.save:    "seed.end"), cluster = c(1, 2, 3, 1, 2, 3, 3))
./permax/tests/test.Rout.save:    nperm = 10, WHseed = attr(uus, "seed.end"), cluster = c(1,
./permax/tests/test.Rout.save:        2, 2, 3, 3, 4, 4, 4), permute.cluster = TRUE)
./permax/tests/test.Rout.save:    nperm = 0, cluster = c(1, 2, 2, 3, 3, 4, 4, 4), permute.cluster = TRUE)
./permax/tests/test.Rout.save:    cluster = clustind)
./permax/tests/test.Rout.save:> # correlations estimated within clusters; average weighted by cluster sizes
./permax/tests/test.Rout.save:    cluster = clustind, stratify = TRUE, weights = table(clustind))
./permax/man/permax.Rd:       WHseed=NULL, cluster=NULL, stratify=FALSE, weights=NULL,
./permax/man/permax.Rd:       nl=50, nr=50, permute.cluster=FALSE, signed.rank=FALSE)
./permax/man/permax.Rd:\item{cluster}{
./permax/man/permax.Rd:  A vector of cluster membership indicators for the columns of
./permax/man/permax.Rd:  \code{data}.  Distinct values of \code{cluster} define distinct
./permax/man/permax.Rd:If \code{TRUE}, statistics will be computed with each cluster, and
./permax/man/permax.Rd:applicable if \code{cluster} is given.
./permax/man/permax.Rd:\item{permute.cluster}{If \code{FALSE}, columns are permuted between
./permax/man/permax.Rd:  is only allowed if all columns in each cluster are in the same group.  Only
./permax/man/permax.Rd:  applicable if \code{cluster} is given.
./permax/man/permax.Rd:  computed.  This option can only be used if cluster is given, all
./permax/man/permax.Rd:  cluster sizes = 2 and each cluster contains both groups (that is, only
./permax/man/permax.Rd:  \code{cluster}, even when \code{stratify=TRUE}.
./permax/man/permax.Rd:If \code{cluster=NULL}, then the columns of \code{data} are assumed to
./permax/man/permax.Rd:be independent.  When \code{cluster} is specified, there are 3 options.  If
./permax/man/permax.Rd:\code{stratify=FALSE} and \code{permute.cluster=FALSE}, then statistics
./permax/man/permax.Rd:the same cluster are exchangeable, while columns from different clusters
./permax/man/permax.Rd:may not be.  If \code{stratify=TRUE} and \code{permute.cluster=FALSE},
./permax/man/permax.Rd:then statistics are also stratified on \code{cluster}.  In this case,
./permax/man/permax.Rd:if cluster effects are very large.  If \code{permute.cluster=TRUE}, then
./permax/man/permax.Rd:it is assumed that group or treatment is defined at the cluster level
./permax/man/permax.Rd:(that is, all members of each cluster are in the same group).  In this
./permax/man/permax.Rd:only whole clusters are permuted to preserve the within cluster
./permax/man/permax.Rd:effects, while the \code{permute.cluster=TRUE} option would examine the
./permax/man/permax.Rd:\code{permute.cluster=TRUE} is not allowed.
./permax/man/permax.Rd:In the special case where each cluster consists of a pair of objects,
./permax/man/permax.Rd:# columns 5,14,15 from cluster 3
./permax/man/permax.Rd:# stratified on cluster, using ranks; equal weights
./permax/man/permax.Rd:# stratified on cluster, using ranks; average weighted by cluster sizes
./permax/man/permcor.Rd:        WHseed=NULL, cluster=NULL, stratify=FALSE, weights=NULL,
./permax/man/permcor.Rd:        permute.cluster=FALSE)
./permax/man/permcor.Rd:\item{cluster}{
./permax/man/permcor.Rd:  A vector of cluster membership indicators for the columns of
./permax/man/permcor.Rd:  \code{data}.  Distinct values of \code{cluster} define distinct
./permax/man/permcor.Rd:If \code{TRUE}, correlations will be estimated within each cluster, and
./permax/man/permcor.Rd:applicable if \code{cluster} is given.
./permax/man/permcor.Rd:\item{permute.cluster}{If \code{FALSE}, values of \code{phen} are
./permax/man/permcor.Rd:  is only allowed if all columns in each cluster have the same value of
./permax/man/permcor.Rd:  applicable if \code{cluster} is given.
./permax/man/permcor.Rd:If \code{cluster=NULL}, then the columns of \code{data} are assumed to
./permax/man/permcor.Rd:be independent.  When \code{cluster} is specified, there are 3 options.  If
./permax/man/permcor.Rd:\code{stratify=FALSE} and \code{permute.cluster=FALSE}, then
./permax/man/permcor.Rd:columns from the same cluster are exchangeable, while columns from
./permax/man/permcor.Rd:\code{permute.cluster=FALSE}, then the analysis is also stratified on
./permax/man/permcor.Rd:\code{cluster}.  In this case correlations are computed separately
./permax/man/permcor.Rd:normalized to sum to 1).  This might be more appropriate if cluster
./permax/man/permcor.Rd:effects are very large.  If \code{permute.cluster=TRUE}, then it is
./permax/man/permcor.Rd:assumed that phenotype is defined at the cluster level (that is, all
./permax/man/permcor.Rd:members of each cluster have the same value of \code{phen}).  In this case
./permax/man/permcor.Rd:individual columns, to preserve the within cluster dependencies.  The
./permax/man/permcor.Rd:combination \code{stratify=TRUE} and \code{permute.cluster=TRUE} is not
./permax/man/permcor.Rd:When \code{permute.cluster=TRUE} and cluster sizes vary, the
./permax/man/permcor.Rd:which cluster that value is assigned to.
./permax/man/permcor.Rd:# columns 5,14,15 from cluster 3
./permax/man/permcor.Rd:# correlations estimated within clusters; average weighted by cluster sizes
./permax/man/permcor.Rd:# permuting clusters: phenotype is a characteristic of the cluster
./permax/man/permcor.Rd:      cluster=c(1,2,2,3,3,4,4,4),permute.cluster=TRUE)
./permax/man/permsep.Rd:permsep(data, ig1, nperm=0, ig2=NULL, WHseed=NULL, cluster=NULL,
./permax/man/permsep.Rd:        stratify=FALSE, permute.cluster=FALSE)
./permax/man/permsep.Rd:\item{cluster}{
./permax/man/permsep.Rd:  A vector of cluster membership indicators for the columns of
./permax/man/permsep.Rd:  \code{data}.  Distinct values of \code{cluster} define distinct
./permax/man/permsep.Rd:applicable if \code{cluster} is given.
./permax/man/permsep.Rd:\item{permute.cluster}{If \code{FALSE}, columns are permuted between
./permax/man/permsep.Rd:  is only allowed if all columns in each cluster are in the same group.  Only
./permax/man/permsep.Rd:  applicable if \code{cluster} is given.
./permax/man/permsep.Rd:cluster, even if values from different clusters overlap.
./permax/man/permsep.Rd:When \code{cluster} is specified and \code{stratify=FALSE}, separation
./permax/man/permsep.Rd:is defined without regard to cluster membership, but only within cluster
./permax/man/permsep.Rd:permutations are examined.  If \code{permute.cluster=TRUE}, then
./permax/man/permsep.Rd:it is assumed that group or treatment is defined at the cluster level
./permax/man/permsep.Rd:(that is, all members of each cluster are in the same group).  In this
./permax/man/permsep.Rd:case separation is again defined without regard to cluster membership, but
./permax/man/permsep.Rd:only whole clusters are permuted to preserve the within cluster
./permax/man/permsep.Rd:effects, while the \code{permute.cluster=TRUE} option would examine the
./permax/man/permsep.Rd:\code{permute.cluster=TRUE} is not allowed.
./permax/man/permsep.Rd:# columns 5,14,15 from cluster 3
./permax/src/ptnstd.f:c If nclust>1, then columns of d must be sorted on cluster, with the first
./permax/src/ptnstd.f:c    mclust(1) columns in cluster 1, the next mclust(2) in cluster 2, etc.
./permax/src/ptnstd.f:c    mct1(j) is the number of columns in group 1 in cluster j
./permax/src/ptnstd.f:c if istrt=1 then tests are stratified on the groups defined by cluster
./permax/src/ptnstd.f:c standardize within cluster
./permax/src/ptn.f:c If nclust>1, then columns of d must be sorted on cluster, with the first
./permax/src/ptn.f:c    mclust(1) columns in cluster 1, the next mclust(2) in cluster 2, etc.
./permax/src/ptn.f:c    mct1(j) is the number of columns in group 1 in cluster j
./permax/src/ptn.f:c if istrt=1 then tests are stratified on the groups defined by cluster
./permax/src/upc.f:c column numbers in clurrent cluster run from i1min to ng
./permax/src/upc.f:c iflg=1 means all possibilities in current cluster exhausted and ig1 reset
./permax/src/tstatc.f:c separation must be in the same direction in each cluster
./sna/R/sna.R:   o$cluster<-hclust(as.dist(equiv.dist),method=cluster.method)
./sna/R/sna.R:   o$cluster.method<-cluster.method
./sna/R/sna.R:      plot(x$cluster,...)
./sna/R/sna.R:      plot(x$cluster,labels=labels,...)
./sna/R/sna.R:   b<-cutree(ec$cluster,k,h)
./sna/R/sna.R:   o$block.membership<-b[ec$cluster$order]
./sna/R/sna.R:   o$order.vector<-ec$cluster$order
./sna/R/sna.R:      o$blocked.data<-dat[,ec$cluster$order,ec$cluster$order]
./sna/R/sna.R:      dimnames(o$blocked.data)<-list(glabels,plabels[ec$cluster$order],plabels[ec$cluster$order])
./sna/R/sna.R:      o$blocked.data<-dat[ec$cluster$order,ec$cluster$order]
./sna/R/sna.R:      dimnames(o$blocked.data)<-list(plabels[ec$cluster$order],plabels[ec$cluster$order])
./sna/R/sna.R:   o$plabels<-plabels[ec$cluster$order]
./sna/R/sna.R:   o$cluster.method<-ec$cluster.method
./sna/R/sna.R:   cat("\tClustering method: ",x$cluster.method,"\n")
./sna/man/sdmat.Rd:Structural distance matrices may be used in the same manner as any other distance matrices (e.g., with multidimensional scaling, cluster analysis, etc.)  Classical null hypothesis tests should not be employed with structural distances, and QAP tests are almost never appropriate (save in the uniquely labeled case).  See \code{\link{cugtest}} for a more reasonable alternative.
./sna/man/sedist.Rd:\keyword{ cluster }%-- one or more ...
./sna/man/structdist.Rd:Structural distance matrices may be used in the same manner as any other distance matrices (e.g., with multidimensional scaling, cluster analysis, etc.)  Classical null hypothesis tests should not be employed with structural distances, and QAP tests are almost never appropriate (save in the uniquely labeled case).  See \code{\link{cugtest}} for a more reasonable alternative.
./sna/man/equiv.clust.Rd:   cluster.method="complete", glabels=dimnames(dat)[[1]][g],
./sna/man/equiv.clust.Rd:  \item{cluster.method}{ The hierarchical clustering method to use (see \code{\link[mva]{hclust}} in package \code{mva}) }
./sna/man/equiv.clust.Rd:This routine is essentially a joint front-end to \code{\link{hclust}} and various positional distance functions, though it defaults to structural equivalence in particular.  Taking the specified graphs as input, \code{equiv.clust} computes the distances between all pairs of positions using \code{equiv.dist}, and then performs a cluster analysis of the result.  The return value is an object of class \code{equiv.clust}, for which various secondary analysis methods exist.
./sna/man/equiv.clust.Rd:\keyword{ cluster }%-- one or more ...
./sna/man/gclust.boxstats.Rd:#Now display boxplots of density by cluster for a two cluster solution
./sna/man/gclust.centralgraph.Rd:\code{gclust.centralgraph} uses \code{\link[mva]{cutree}} to cut the hierarchical clustering in \code{h} into \code{k} groups.  \code{\link{centralgraph}} is then called on each cluster, and the results are returned as a graph stack.  This is a useful tool for interpreting clusters of (labeled) graphs, with the resulting central graphs being subsequently analyzed using standard SNA methods.
./sna/man/gclust.centralgraph.Rd:#Now find central graphs by cluster for a two cluster solution
./sna/man/gclust.centralgraph.Rd:\keyword{ cluster }%-- one or more ...
./vegan/R/ordicluster.R:    function (ord, cluster, prune=0, display="sites", w = weights(ord, display),  ...)
./vegan/R/ordicluster.R:    mrg <- cluster$merge
./vegan/R/ordicluster.R:        stop("Dimensions do not match in `ord' and `cluster'")
./vegan/man/vegemite.Rd:  variables or results from an ordination or cluster analysis.
./vegan/man/vegemite.Rd:  as in the cluster dendrogram.
./vegan/man/ordihull.Rd:  points, `spider' graphs, ellipses, cluster dendrogram or spanning
./vegan/man/ordihull.Rd:ordicluster(ord, cluster, prune = 0, display = "sites",
./vegan/man/ordihull.Rd:  \item{cluster}{Result of hierarchic cluster analysis, such as
./vegan/man/ordihull.Rd:    \code{\link[mva]{hclust}} or \code{\link[cluster]{agnes}}.}
./vegan/man/ordihull.Rd:  \code{\link[cluster]{ellipsoidhull}} of package \code{cluster}.
./vegan/man/ordihull.Rd:  Function \code{ordicluster} overlays a cluster dendrogram onto
./vegan/man/ordihull.Rd:  \code{\link[mva]{hclust}} or \code{\link[cluster]{agnes}}, or other
./vegan/man/ordihull.Rd:  cluster centroids to each other with line
./vegan/man/distconnected.Rd:  \code{\link[cluster]{agnes}}. However, these functions combine
./vegan/man/distconnected.Rd:    \code{\link[cluster]{agnes}} for single linkage clustering.
./vegan/inst/WhatsNew.txt:  overlay a cluster dendrogram or a spanning tree onto an
./sptests/man/localG.Rd:of a local cluster of high values of the variable being analysed, very
./sptests/man/localG.Rd:low relative values a similar cluster of low values. For inference,
./moc/man/moc.Rd:\keyword{cluster}
./mda.Rcheck/mda/R/mda:			wmj <- diag(nc)[TT$cluster,  ]
./mda.Rcheck/mda/R/mda:            wmj <- diag(nc)[TT$cluster, ]
./geepack/R/geese.R:    if (max(waves) != maxclsz) stop("maximum waves and maximum cluster size not equal")
./geepack/R/geese.R:    if (length(mean.link.v) != maxclsz) stop("length of mean.link not equal to the maximum cluster size.")
./geepack/R/summary.R:  ##cat("\nMaximum cluster size   : ", x$max.id, "\n")
./geepack/R/summary.R:  cat("Number of clusters:  ", length(x$clusz), "  Maximum cluster size:", max(x$clusz), "\n\n")
./geepack/R/summary.R:  ##cat("\nMaximum cluster size   : ", x$max.id, "\n")
./geepack/R/summary.R:  cat("Number of clusters:  ", length(x$clusz), "  Maximum cluster size:", max(x$clusz), "\n\n")
./geepack/man/geese.Rd:    to be sorted so that observations on a cluster are contiguous rows
./geepack/man/geese.Rd:    cluster should use the same link.
./geepack/man/geese.Rd:  x1 <- rbinom(200, 1, 0.6) ## within cluster varying binary covariate
./geepack/man/geese.Rd:  x2 <- runif(200, 0, 1)   ## within cluster varying continuous covariate
./geepack/man/geese.Rd:#### Next, we introduce non-constant cluster sizes by
./geepack/man/ordgee.Rd:    to be sorted so that observations on a cluster are contiguous rows
./geepack/man/ordgee.Rd:    of z is \deqn{c^2 \sum n_i(n_i - 1)/2,} where \eqn{n_i} is the cluster
./geepack/src/gee2.cc:  Clusz: cluster sizes;
./geepack/src/gee2.cc:  ZcorSize: number of rows in Zcor for each cluster;
./geepack/src/ordgee.cc:  else { //cluster size greater than 1;
./geepack/src/ordgee.cc:  else { //cluster size greater than 1;
./geepack/src/ordgee.cc:/* the following estimation procedure assumed that each cluster has size
./geepack/src/ordgee.cc:    int clsz = sum(Scuri); //this is the new cluster size that should be passed down!!!!!!!
./geepack/src/ordgee.cc:  //only those cluster with size 2 or more contributes to the variance of alpha
./fpc/man/fixreg.Rd:    required cluster
./fpc/man/fixreg.Rd:    cluster to be found with
./fpc/man/fixreg.Rd:    probability for a cluster of size \code{irnc} to be found.}
./fpc/man/fixreg.Rd:    probability for a cluster of size \code{mnc} to be found.}
./fpc/man/fixreg.Rd:    dimension, where the vectors of \code{init.group} indicate cluster
./fpc/man/fixreg.Rd:  chosen for every Single Linkage cluster of FPCs according to the
./fpc/man/fixreg.Rd:# Every found fixed point cluster is reported,
./fpc/man/fixreg.Rd:\keyword{cluster}% at least one, from doc/KEYWORDS
./fpc/man/fixmahal.Rderr:    required cluster
./fpc/man/fixmahal.Rderr:    and a single representative FPC is reported as a cluster
./fpc/man/fixmahal.Rderr:    dimension, where the vectors of \code{init.group} indicate cluster
./fpc/man/fixmahal.Rderr:  chosen for every Single Linkage cluster of FPCs according to the
./fpc/man/fixmahal.Rderr:  plot(face, col=1+cff1[[6]]) # Why does this come out as a cluster?
./fpc/man/fixmahal.Rderr:\keyword{cluster}% at least one, from doc/KEYWORDS
./fpc/man/fpclusters.Rd:\title{Extracting clusters from fixed point cluster objects}
./fpc/man/fpclusters.Rd:  weights of the cluster memberships.
./fpc/man/fpclusters.Rd:\keyword{cluster}% at least one, from doc/KEYWORDS
./fpc/man/clusexpect.Rd:  cluster is found}
./fpc/man/clusexpect.Rd:  cluster (FPC) of size \code{n} is found in \code{ir} fixed point
./fpc/man/clusexpect.Rd:\keyword{cluster}
./fpc/man/cmahal.Rd:  the number of points and variables of the current fixed point cluster
./fpc/man/cmahal.Rd:\keyword{cluster}% at least one, from doc/KEYWORDS
./fpc/man/mahalconf.Rd:\keyword{cluster}
./fpc/man/rFace.Rd:  The function generates a nice benchmark example for cluster
./fpc/man/rFace.Rd:  \code{grouping} is a factor giving the cluster numbers, see below.
./fpc/man/rFace.Rd:  outliers than a cluster in itself. This group contains
./fpc/man/rFace.Rd:  cluster 1, the chin (quadratic function plus noise).
./fpc/man/rFace.Rd:  10\% belong to cluster 2, the right eye (Gaussian). 30\% belong to
./fpc/man/rFace.Rd:  cluster 3, the mouth (Gaussian/squared Gaussian).
./fpc/man/rFace.Rd:  20\% belong to cluster 4, the nose (Gaussian/gamma), and
./fpc/man/rFace.Rd:  20\% belong to cluster 5, the left eye (uniform).
./fpc/man/rFace.Rd:  \item{grouping}{a factor giving the cluster memberships of the points.}
./fpc/man/fixmahal.Rd:    required cluster
./fpc/man/fixmahal.Rd:    dimension, where the vectors of \code{init.group} indicate cluster
./fpc/man/fixmahal.Rd:  chosen for every Single Linkage cluster of FPCs according to the
./fpc/man/fixmahal.Rd:    tuning constant \code{ca} corresponding to the cluster sizes from
./fpc/man/fixmahal.Rd:  plot(face, col=1+cff1[[6]]) # Why does this come out as a cluster?
./fpc/man/fixmahal.Rd:\keyword{cluster}% at least one, from doc/KEYWORDS
./fpc/man/itnumber.Rd:\title{Number of regression fixed point cluster iterations}
./fpc/man/itnumber.Rd:  a fixed point cluster (FPC) of size
./fpc/man/itnumber.Rd:\keyword{cluster}% __ONLY ONE__ keyword per line
./fpc/man/minsize.Rd:\title{Minimum size of regression fixed point cluster}
./fpc/man/minsize.Rd:  Computes the minimum size of a fixed point cluster (FPC) which is
./fpc/man/minsize.Rd:\keyword{cluster}% __ONLY ONE__ keyword per line
./fpc/man/randcmatrix.Rd:\keyword{cluster}% at least one, from doc/KEYWORDS
./fpc/man/regmix.Rd:    of membership to every cluster. As generated by \code{\link{randcmatrix}}.}
./fpc/man/regmix.Rd:  \item{eps}{vector of cluster proportion estimators.}
./fpc/man/regmix.Rd:  \item{g}{integer vector of estimated cluster numbers for the points
./fpc/man/regmix.Rd:\keyword{cluster}% at least one, from doc/KEYWORDS
./fpc/man/concomp.Rd:\keyword{cluster}% __ONLY ONE__ keyword per line
./fpc/R/fpc.R:    cat("Cluster equals whole dataset => No cluster plot is done.\n")
./fpc/R/fpc.R:  cat("Often a clear cluster in the data leads to several similar FPCs.\n")
./fpc/R/fixreg.R:# clusexpect= Expectation of times found for a cluster of given size under
./fpc/R/fixreg.R:# Calculates iteration number such that theoretical probability that cluster
./fpc/R/fixreg.R:  cat("Often a clear cluster in the data leads to several similar FPCs.\n")
./fpc/R/regmix.R:# output: coef=regression coefficients, var=residual variances, eps=cluster
./fpc/R/regmix.R:# if too small or collinear cluster
./fpc/R/regmix.R:        if (warnings) warning("Too small cluster")
./fpc/R/regmix.R:      } # if too small cluster
./fpc/R/regmix.R:      } # else (cluster large enough)
./fpc/R/regmix.R:# ir=iteration runs, nclust= cluster numbers vector, icrit=iteration stopping
./fpc/R/regmix.R:# eps: cluster proportions, z:a posteriori probabilities, g:optimal
./fpc/R/discrproj2.R:# subsample: size of subsample of cluster to use (0=all)
./fpc/INDEX:                        point cluster is found
./fpc/INDEX:fpclusters              Extracting clusters from fixed point cluster
./fpc/INDEX:itnumber                Number of regression fixed point cluster
./fpc/INDEX:minsize                 Minimum size of regression fixed point cluster
./fpc/tests/examples.Rout.save:Often a clear cluster in the data leads to several similar FPCs.
./fpc/tests/examples.Rout.save:Often a clear cluster in the data leads to several similar FPCs.
./fpc/tests/examples.Rout.save:Often a clear cluster in the data leads to several similar FPCs.
./fpc/tests/examples.Rout.save:Often a clear cluster in the data leads to several similar FPCs.
./fpc/tests/examples.Rout.save:Often a clear cluster in the data leads to several similar FPCs.
./fpc/tests/examples.Rout.save:Often a clear cluster in the data leads to several similar FPCs.
./fpc/tests/examples.Rout.save:Often a clear cluster in the data leads to several similar FPCs.
./fpc/tests/examples.Rout.save:Often a clear cluster in the data leads to several similar FPCs.
./fpc/tests/examples.Rout.save:Often a clear cluster in the data leads to several similar FPCs.
./fpc/tests/examples.Rout.save:Often a clear cluster in the data leads to several similar FPCs.
./fpc/tests/examples.Rout.save:Often a clear cluster in the data leads to several similar FPCs.
./fpc/tests/examples.Rout.save:Often a clear cluster in the data leads to several similar FPCs.
./fpc/DESCRIPTION:Description: Fuzzy and crisp fixed point cluster analysis
./pamr/R/pamr.makeclasses.R:  require(cluster)
./pamr/man/pamr.makeclasses.Rd:also check that the labels on the  final redrawn cluster tree agrees with the desired
./pamr/inst/doc/readme.html:final redrawn cluster tree agrees with the desired classes.</P>
./mda.R-devel-check/mda/R/mda:			wmj <- diag(nc)[TT$cluster,  ]
./mda.R-devel-check/mda/R/mda:            wmj <- diag(nc)[TT$cluster, ]
./spatstat/R/random.S:#    rMatClust()       Mat'ern cluster process
./spatstat/R/random.S:  # Implementation for bounded cluster radius
./spatstat/R/random.S:    cluster <- rcluster(parents$x[i], parents$y[i], ...)
./spatstat/R/random.S:    cluster <- ppp(cluster$x, cluster$y, window=frame)
./spatstat/R/random.S:    cluster <- cluster[,win]
./spatstat/R/random.S:    result <- superimpose(result, cluster)
./spatstat/man/rMatClust.Rd:    Intensity of the Poisson process of cluster centres.
./spatstat/man/rMatClust.Rd:    Mean number of points per cluster.
./spatstat/man/rMatClust.Rd:  This algorithm generates a realisation of Mat\'ern's cluster process
./spatstat/man/rMatClust.Rd:  replaced by a random cluster of points, the number of points in each
./spatstat/man/rMatClust.Rd:  cluster being random with a Poisson (\code{mu}) distribution,
./spatstat/man/rNeymanScott.Rd:  Neyman-Scott cluster process.
./spatstat/man/rNeymanScott.Rd:    Intensity of the Poisson process of cluster centres.
./spatstat/man/rNeymanScott.Rd:    Maximum radius of a random cluster.
./spatstat/man/rNeymanScott.Rd:  general Neyman-Scott process, with the cluster mechanism
./spatstat/man/rNeymanScott.Rd:  replaced by a random cluster of points, created by calling the
./spatstat/man/rNeymanScott.Rd:  \eqn{x} and \code{y} coordinates of the points in the cluster.
./spatstat/man/rThomas.Rd:  Thomas cluster process.
./spatstat/man/rThomas.Rd:    Intensity of the Poisson process of cluster centres.
./spatstat/man/rThomas.Rd:    Standard deviation of displacement of a point from its cluster centre.
./spatstat/man/rThomas.Rd:    Expected number of points per cluster.
./spatstat/man/rThomas.Rd:  replaced by a random cluster of points, the number of points
./spatstat/man/rThomas.Rd:  per cluster being Poisson (\code{mu}) distributed, and their
./spatstat/man/rThomas.Rd:  cluster parent location.
./snow/R/snow.R:#**** check valid cluster option
./snow/R/snow.R:        stop("need to specify a cluster type")
./snow/R/snow.R:        stop("unknown cluster type"))
./snow/R/snow.R:        stop("data lengh must be at most cluster size")
./snow/R/mpi.R:    if (! is.null(getMPIcluster())) stop("MPI cluster already running")
./snow/R/mpi.R:	# use process spawning to create cluster
./snow/R/mpi.R:            stop(paste("a cluster already exists", comm))
./snow/R/mpi.R:#**** need .Last to make sure cluster is shut down on exit of master
./snow/README:to start a cluster of slave processes; the master process then uses
./snow/README:to be available on all hosts that are to be used for a cluster.
./snow/README:the master as well insures that the cluster startup mechanism assumes
./snow/README:an inhomogeneous cluster by default.  R should also be on the PATH of
./snow/README:http://www.stat.uiowa.edu/~luke/R/cluster/cluster.html.
./snow/man/snow-rand.Rd:  \item{cl}{cluster object}
./snow/man/snow-rand.Rd:  SNOW cluster.
./snow/man/snow-rand.Rd:  \url{http://www.stat.uiowa.edu/~luke/R/cluster/cluster.html}.
./snow/man/snow-parallel.Rd:  \item{cl}{cluster object}
./snow/man/snow-parallel.Rd:  \url{http://www.stat.uiowa.edu/~luke/R/cluster/cluster.html}.
./snow/man/snow-startstop.Rd:  \item{spec}{cluster specification}
./snow/man/snow-startstop.Rd:  \item{options}{cluster options object}
./snow/man/snow-startstop.Rd:  \item{cl}{cluster object}
./snow/man/snow-startstop.Rd:  \item{...}{cluster option specifications}
./snow/man/snow-startstop.Rd:  \item{type}{character; specifies cluster type.}
./snow/man/snow-startstop.Rd:  Functions to start and stop a SNOW cluster and to set default cluster
./snow/man/snow-startstop.Rd:  \code{makeCluster} starts a cluster of the specified or default type
./snow/man/snow-startstop.Rd:  and returns a reference to the cluster.  Supported cluster types are
./snow/man/snow-startstop.Rd:  \code{stopCluster} should be called to properly shut down the cluster
./snow/man/snow-startstop.Rd:  values for default cluster options.  There are many options.  The
./snow/man/snow-startstop.Rd:  \code{makeMPIcluster} can be used to start a cluster of the
./snow/man/snow-startstop.Rd:  the corresponding cluster will have been pre-constructed and can be obtained
./snow/man/snow-startstop.Rd:  \url{http://www.stat.uiowa.edu/~luke/R/cluster/cluster.html}.
./snow/man/snow-cluster.Rd:\name{snow-cluster}
./snow/man/snow-cluster.Rd:  \item{cl}{cluster object}
./snow/man/snow-cluster.Rd:  Functions for computing on a SNOW cluster.
./snow/man/snow-cluster.Rd:  These are the basic functions for computing on a cluster.  All
./snow/man/snow-cluster.Rd:  the result lists returned by the cluster computing functions can a
./snow/man/snow-cluster.Rd:  \code{...} on each node in the cluster \code{cl} and returns a list
./snow/man/snow-cluster.Rd:  \code{clusterEvalQ} evaluates a literal expression on each cluster node.
./snow/man/snow-cluster.Rd:  It a cluster version of \code{evalq}, and is a convenience function
./snow/man/snow-cluster.Rd:  \code{clusterApply} calls \code{fun} on the first cluster node
./snow/man/snow-cluster.Rd:  must be less than or equal to the number of nodes in the cluster.
./snow/man/snow-cluster.Rd:  cluster nodes \code{n}, then the first \code{n} jobs are placed in
./snow/man/snow-cluster.Rd:  cluster utilization than using \code{clusterApply}.  However,
./snow/man/snow-cluster.Rd:  each cluster and returns the result as a list with length equal to the
./snow/man/snow-cluster.Rd:  number of cluster nodes.  Currently the pieces are chosen to be close
./snow/man/snow-cluster.Rd:  \url{http://www.stat.uiowa.edu/~luke/R/cluster/cluster.html}.
./survival/man/cluster.Rd:\name{cluster}
./survival/man/cluster.Rd:\alias{cluster}
./survival/man/cluster.Rd:cluster(x)
./survival/man/cluster.Rd:cluster indicator.
./survival/man/cluster.Rd:coxph(Surv(futime, fustat) ~ age + cluster(group), data = ovarian)
./survival/man/coxph.Rd:model includes a \code{cluster()} operative, \code{FALSE} otherwise.
./survival/man/coxph.Rd:The \code{cluster} term is used to compute a robust variance for the model.
./survival/man/coxph.Rd:The term \code{+ cluster(id)}, where \code{id == unique(id)}, is equivalent to
./survival/man/coxph.Rd:\code{\link{cluster}}, \code{\link{survfit}}, \code{\link{Surv}}, \code{\link{strata}},\code{\link{ridge}}, \code{\link{pspline}},\code{\link{frailty}}.}
./survival/R/coxph.s:    special <- c("strata", "cluster")
./survival/R/coxph.s:    cluster<- attr(Terms, "specials")$cluster
./survival/R/coxph.s:    if (length(cluster)) {
./survival/R/coxph.s:	cluster <- strata(m[,tempc$vars], shortlabel=TRUE)  #allow multiples
./survival/R/coxph.s:	    if (length(cluster)) {
./survival/R/coxph.s:		temp <- residuals.coxph(fit2, type='dfbeta', collapse=cluster,
./survival/R/coxph.s:		temp0 <- residuals.coxph(fit2, type='score', collapse=cluster,
./survival/R/coxph.getdata.s:	    dropx <- untangle.specials(Terms, 'cluster')$terms
./survival/R/predict.coxph.s:    if (length(attr(Terms, 'specials')$cluster)) {
./survival/R/predict.coxph.s:	temp <- untangle.specials(Terms, 'cluster', 1)
./survival/R/summary.coxph.s:	  "assume independence of\n     observations within a cluster,",
./survival/R/survfit.coxph.s:    cluster<-attr(Terms, "specials")$cluster
./survival/R/survfit.coxph.s:    if (length(cluster)) {
./survival/R/survfit.coxph.s:	temp <- untangle.specials(Terms, 'cluster')
./survival/R/survfit.coxph.s:    #  (The coxph.getdata routine never returns cluster() terms).
./survival/R/survreg.s:    special <- c("strata", "cluster")
./survival/R/survreg.s:    cluster<- attr(Terms, "specials")$cluster
./survival/R/survreg.s:    if (length(cluster)) {
./survival/R/survreg.s:        cluster <- strata(m[,tempc$vars], shortlabel=TRUE)  #allow multiples
./survival/R/cluster.s:#SCCS @(#)cluster.s	4.1 10/01/94
./survival/R/cluster.s:cluster <- function(x) x
./survival/INDEX:cluster 	 Identify clusters.
./survival/Examples/test/fit.bladder.s:		 cluster(id), bladder, method='breslow')
./survival/Examples/test/fit.bladder.s:fita <- coxph(Surv(start, stop, event) ~ rx + size + number + cluster(id),
./survival/Examples/test/Rtest:		 cluster(id), bladder, method='breslow')
./survival/Examples/test/Rtest:fita <- coxph(Surv(start, stop, event) ~ rx + size + number + cluster(id),
./survival/Examples/test/testall.save:+ 		 cluster(id), bladder, method="breslow")
./survival/Examples/test/testall.save:	cluster(id), data = bladder, method = "breslow")
./survival/Examples/test/testall.save:> fita <- coxph(Surv(start, stop, event) ~ rx + size + number + cluster(id),
./survival/Examples/test/testall.save:coxph(formula = Surv(start, stop, event) ~ rx + size + number + cluster(id),
./survival/Examples/test/Rtest.out.save:+ 		 cluster(id), bladder, method='breslow')
./survival/Examples/test/Rtest.out.save:    cluster(id), data = bladder, method = "breslow")
./survival/Examples/test/Rtest.out.save:> fita <- coxph(Surv(start, stop, event) ~ rx + size + number + cluster(id),
./survival/Examples/test/Rtest.out.save:    cluster(id), data = bladder2, method = "breslow")
./survival/Examples/test/Rtest.out:+ 		 cluster(id), bladder, method='breslow')
./survival/Examples/test/Rtest.out:    cluster(id), data = bladder, method = "breslow")
./survival/Examples/test/Rtest.out:> fita <- coxph(Surv(start, stop, event) ~ rx + size + number + cluster(id),
./survival/Examples/test/Rtest.out:    cluster(id), data = bladder2, method = "breslow")
./survival/Examples/test/Testlog:	    doovarian.s  added a test that robust=T and cluster() give the
./survival/Examples/testfrail/Rtest:fitc1 <- coxph(Surv(time, status) ~ rx + extent + node4 + cluster(id)
./survival/Examples/testfrail/Rtest:fitc5 <- coxph(Surv(time, status) ~ rx + extent + node4 +cluster(id)
./survival/Examples/testfrail/Rtest:r2fit0 <- coxph(Surv(start, stop, status) ~ rx + cluster(id), rat2)
./survival/Examples/testfrail/colon.s:fitc1 <- coxph(Surv(time, status) ~ rx + extent + node4 + cluster(id)
./survival/Examples/testfrail/colon.s:fitc5 <- coxph(Surv(time, status) ~ rx + extent + node4 +cluster(id)
./survival/Examples/testfrail/Rtest.out:> fitc1 <- coxph(Surv(time, status) ~ rx + extent + node4 + cluster(id)
./survival/Examples/testfrail/Rtest.out:coxph(formula = Surv(time, status) ~ rx + extent + node4 + cluster(id) +
./survival/Examples/testfrail/Rtest.out:> fitc5 <- coxph(Surv(time, status) ~ rx + extent + node4 +cluster(id)
./survival/Examples/testfrail/Rtest.out:> r2fit0 <- coxph(Surv(start, stop, status) ~ rx + cluster(id), rat2)
./survival/Examples/testfrail/Rtest.out:coxph(formula = Surv(start, stop, status) ~ rx + cluster(id),
./survival/Examples/testfrail/Rtest.out.save:> fitc1 <- coxph(Surv(time, status) ~ rx + extent + node4 + cluster(id)
./survival/Examples/testfrail/Rtest.out.save:coxph(formula = Surv(time, status) ~ rx + extent + node4 + cluster(id) +
./survival/Examples/testfrail/Rtest.out.save:> fitc5 <- coxph(Surv(time, status) ~ rx + extent + node4 +cluster(id)
./survival/Examples/testfrail/Rtest.out.save:> r2fit0 <- coxph(Surv(start, stop, status) ~ rx + cluster(id), rat2)
./survival/Examples/testfrail/Rtest.out.save:coxph(formula = Surv(start, stop, status) ~ rx + cluster(id),
./survival/Examples/testfrail/testall.save:> fitc1 <- coxph(Surv(time, status) ~ rx + extent + node4 + cluster(id)
./survival/Examples/testfrail/testall.save:coxph(formula = Surv(time, status) ~ rx + extent + node4 + cluster(id) + strata(
./survival/Examples/testfrail/testall.save:> fitc5 <- coxph(Surv(time, status) ~ rx + extent + node4 +cluster(id)
./survival/Examples/testfrail/testall.save:> > r2fit0 <- coxph(Surv(start, stop, status) ~ rx + cluster(id), rat2)
./survival/Examples/testfrail/testall.save:coxph(formula = Surv(start, stop, status) ~ rx + cluster(id), data = rat2)
./survival/Examples/testfrail/rat2.s:r2fit0 <- coxph(Surv(start, stop, status) ~ rx + cluster(id), rat2)
./survival/Changelog:contained a cluster() statement -- it was trying to create a column for this
./survival/Changelog:and of course the X matrix doesn't have one; cluster() only effects variance
./survival/Changelog:estimation.  Predict now ignores "cluster" terms.
./glmmML/R/glmmML.R:                   cluster = NULL,
./glmmML/R/glmmML.R:  mixed <- ( !is.null(cluster) ) && ( n.points >= 2 )
./glmmML/R/glmmML.R:                    cluster,
./glmmML/R/glmmML.fit.R:                        cluster = NULL,
./glmmML/R/glmmML.fit.R:  ord <- order(cluster)
./glmmML/R/glmmML.fit.R:  cluster <- cluster[ord]
./glmmML/R/glmmML.fit.R:  fam.size <- as.vector(table(cluster))
./glmmML/man/glmmML.Rd:glmmML(formula, data = list(), cluster = NULL, family = binomial,
./glmmML/man/glmmML.Rd:  \item{cluster}{Factor indicating which items are correlated}
./glmmML/man/glmmML.Rd:glmmML(y ~ x1, data = dat, cluster = id)
./glmmML/man/glmmML.fit.Rd:glmmML.fit(X, Y, start.coef = NULL, start.sigma = NULL, mixed = FALSE, cluster = NULL, offset = rep(0, nobs), family = binomial(), n.points = 16, control = glm.control(), method, intercept = TRUE)
./glmmML/man/glmmML.fit.Rd:  \item{cluster}{The clustring variable.}
./glmmML/man/glmmML.fit.Rd:glmmML.fit(x, y, cluster = id, mixed = TRUE, method = 1)
./mclust1998/INDEX:one.XXX                 Log-likelihood for a single cluster
./mclust1998/TITLE:mclust1998	Model-based cluster analysis: the 1998 version of MCLUST
./mclust1998/R/mclust.R:### one cluster case
./mclust1998/R/mclust.R:### one cluster case
./mclust1998/R/mclust.R:### one cluster case
./mclust1998/R/mclust.R:					## one cluster case
./mclust1998/R/mclust.R:					## one cluster case
./mclust1998/R/mclust.R:					## one cluster case
./mclust1998/man/traceW.Rd:\keyword{cluster}
./mclust1998/man/mhtree.EEE.Rd:singleton cluster.
./mclust1998/man/mhtree.EEE.Rd:\keyword{cluster}
./mclust1998/man/one.XXX.Rd:\title{Log-likelihood for a single cluster}
./mclust1998/man/one.XXX.Rd:  unconstrained Gaussian cluster; \code{one.XI} calculates the
./mclust1998/man/one.XXX.Rd:  log-likelihood for a single Gaussian spherical cluster.
./mclust1998/man/one.XXX.Rd:\keyword{cluster}
./mclust1998/man/mhtree.EFV.Rd:singleton cluster.
./mclust1998/man/mhtree.EFV.Rd:\keyword{cluster}
./mclust1998/man/censcale.Rd:\keyword{cluster}
./mclust1998/man/mhtree.EI.Rd:singleton cluster.
./mclust1998/man/mhtree.EI.Rd:\keyword{cluster}
./mclust1998/man/me.EI.Rd:\keyword{cluster}
./mclust1998/man/mstep.Rd:\keyword{cluster}
./mclust1998/man/mhtree.VI.Rd:singleton cluster.
./mclust1998/man/mhtree.VI.Rd:\keyword{cluster}
./mclust1998/man/me.EEE.Rd:\keyword{cluster}
./mclust1998/man/me.EEV.Rd:\keyword{cluster}
./mclust1998/man/me.VI.Rd:\keyword{cluster}
./mclust1998/man/me.Rd:\keyword{cluster}
./mclust1998/man/mhclass.Rd:\keyword{cluster}
./mclust1998/man/mixproj.Rd:### Plot only one cluster
./mclust1998/man/mixproj.Rd:\keyword{cluster}
./mclust1998/man/mstep.EI.Rd:\keyword{cluster}
./mclust1998/man/mstep.VI.Rd:\keyword{cluster}
./mclust1998/man/print.emclust.Rd:\keyword{cluster}
./mclust1998/man/emclust.Rd:Answers via model-based cluster analysis. }Technical Report No. 329,
./mclust1998/man/emclust.Rd:\keyword{cluster}
./mclust1998/man/mhtree.VFV.Rd:singleton cluster.
./mclust1998/man/mhtree.VFV.Rd:\keyword{cluster}
./mclust1998/man/partuniq.Rd:\keyword{cluster}
./mclust1998/man/plot.emclust.Rd:\keyword{cluster}
./mclust1998/man/mhtree.VVV.Rd:singleton cluster.
./mclust1998/man/mhtree.VVV.Rd:\keyword{cluster}
./mclust1998/man/clpairs.Rd:\keyword{cluster}
./mclust1998/man/bic.Rd:is missing, a single cluster is assumed (all noise if \code{noise = TRUE}).
./mclust1998/man/bic.Rd:Answers via model-based cluster analysis. }Technical Report No. 329,
./mclust1998/man/bic.Rd:\keyword{cluster}
./mclust1998/man/estep.EI.Rd:\keyword{cluster}
./mclust1998/man/estep.Rd:\keyword{cluster}
./mclust1998/man/me.VEV.Rd:\keyword{cluster}
./mclust1998/man/estep.VI.Rd:\keyword{cluster}
./mclust1998/man/me.VVV.Rd:\keyword{cluster}
./mclust1998/man/loglik.Rd:\keyword{cluster}
./mclust1998/man/awe.Rd:\keyword{cluster}
./mclust1998/man/ztoc.Rd:    and each cluster one column.}
./mclust1998/man/ztoc.Rd:\keyword{cluster}%-- one or more ...
./mclust1998/man/mstep.EEE.Rd:\keyword{cluster}
./mclust1998/man/mstep.EEV.Rd:\keyword{cluster}
./mclust1998/man/estep.EEE.Rd:\keyword{cluster}
./mclust1998/man/hypvol.Rd:\keyword{cluster}
./mclust1998/man/partconv.Rd:\keyword{cluster}
./mclust1998/man/mhtree.Rd:singleton cluster.
./mclust1998/man/mhtree.Rd:\keyword{cluster}
./mclust1998/man/mstep.VEV.Rd:\keyword{cluster}
./mclust1998/man/mstep.VVV.Rd:\keyword{cluster}
./mclust1998/man/estep.VVV.Rd:\keyword{cluster}
./mclust1998/man/emclust1.Rd:Answers via model-based cluster analysis. }Technical Report No. 329,
./mclust1998/man/emclust1.Rd:\keyword{cluster}
./mclust1998/man/estep.XEV.Rd:\keyword{cluster}
./mclust1998/man/summary.emclust1.Rd:\keyword{cluster}
./mclust1998/man/summary.emclust.Rd:\keyword{cluster}
./mclust1998/src/blapack.f:*          (or cluster) is considered to be located if it has been
./mclust1998/src/mclust.f:c cluster volumes are equal but unknown, and orientation is allowed to vary
./mclust1998/src/mclust.f:c are fixed in advance, while cluster volumes are also equal but unknown.
./mclust1998/src/mclust.f:c likelihood and cluster size for Gaussian hierarchical clustering in which
./mclust1998/src/mclust.f:c  new     integer (output) (ns) The size of the new cluster formed at each
./mclust1998/src/mclust.f:c likelihood and cluster size for Gaussian hierarchical clustering in which
./mclust1998/src/mclust.f:c  new     integer (output) (ns) The size of the new cluster formed at each
./mclust1998/src/mclust.f:c likelihood and cluster size for Gaussian hierarchical clustering in which
./mclust1998/src/mclust.f:c  new     integer (output) (ns) The size of the new cluster formed at each
./mclust1998/src/mclust.f:c likelihood and cluster size for Gaussian hierarchical clustering in which
./mclust1998/src/mclust.f:c  new     integer (output) (ns) The size of the new cluster formed at each
./mclust1998/src/mclust.f:c likelihood and cluster size for Gaussian hierarchical clustering in which
./mclust1998/src/mclust.f:c  new     integer (output) (ns) The size of the new cluster formed at each
./mclust1998/src/mclust.f:c likelihood and cluster size for Gaussian hierarchical clustering in which
./mclust1998/src/mclust.f:c  new     integer (output) (ns) The size of the new cluster formed at each
./mclust1998/src/mclust.f:c loglikelihood for a single Gaussian spherical cluster
./mclust1998/src/mclust.f:c  mu      double  (ouput) (p) MLE for cluster mean.
./mclust1998/src/mclust.f:c  sigsq   double  (output) sigma-squared for the cluster.
./mclust1998/src/mclust.f:c loglikelihood for a single Gaussian unconstrained cluster
./mclust1998/DESCRIPTION:Description: 	Model-based cluster analysis: the 1998 version of MCLUST
./mclust1998/DESCRIPTION:Title: 		Model-based cluster analysis
./mclust1998/README.S:MCLUST is a software package for cluster analysis based on parameterized
./mclust1998/README.S:functions for cluster analysis (see below).
./mclust1998/README.S:plots the 3-cluster class from mhtree().
./mclust1998/README.S:MCLUST provides two functions, emclust1() and emclust(), for cluster analysis
./mclust1998/README.S:there are either 2 or 3 clusters in the data. The 2 cluster EM result
./mclust1998/README.S:separates the first species from the other two, while the 3 cluster result
./CRAN-contrib/Descriptions/maptree.DESCRIPTION:Depends: R (>= 1.0), mva, cluster, rpart, combinat
./CRAN-contrib/Descriptions/survival.INDEX:cluster 	 Identify clusters.
./CRAN-contrib/Descriptions/splancs.INDEX:pcp                     Fit a Poisson cluster process
./CRAN-contrib/Descriptions/e1071.INDEX:boxplot.bclust          Boxplot of cluster profiles
./CRAN-contrib/Descriptions/mclust1998.DESCRIPTION:Description: 	Model-based cluster analysis: the 1998 version of MCLUST
./CRAN-contrib/Descriptions/mclust1998.DESCRIPTION:Title: 		Model-based cluster analysis
./CRAN-contrib/Descriptions/mclust.DESCRIPTION:Title: 		Model-based cluster analysis
./CRAN-contrib/Descriptions/mclust.DESCRIPTION:Description: 	Model-based cluster analysis: the 2002 version of MCLUST
./CRAN-contrib/Descriptions/cluster.DESCRIPTION:Package: cluster
./CRAN-contrib/Descriptions/cluster.DESCRIPTION:Description: Functions for cluster analysis, originally from
./CRAN-contrib/Descriptions/cluster.INDEX:*** cluster/INDEX ***
./CRAN-contrib/Descriptions/cluster.INDEX:cluster-internal        Internal cluster functions
./CRAN-contrib/Descriptions/mclust1998.INDEX:one.XXX                 Log-likelihood for a single cluster
./CRAN-contrib/Descriptions/survey.DESCRIPTION:Description: Summary statistics, generalised linear models, and general maximum pseudolikelihood estimation for stratified, cluster-sampled, unequally weighted survey samples. Variances by Taylor series linearisation or replicate weights
./CRAN-contrib/Descriptions/fpc.DESCRIPTION:Description: Fuzzy and crisp fixed point cluster analysis
./CRAN-contrib/Descriptions/fpc.INDEX:                        point cluster is found
./CRAN-contrib/Descriptions/fpc.INDEX:fpclusters              Extracting clusters from fixed point cluster
./CRAN-contrib/Descriptions/fpc.INDEX:itnumber                Number of regression fixed point cluster
./CRAN-contrib/Descriptions/fpc.INDEX:minsize                 Minimum size of regression fixed point cluster
./CRAN-contrib/Descriptions/Hmisc.INDEX:deff            Kish design effect and intra-cluster correlation
./CRAN-contrib/Descriptions/Hmisc.INDEX:t.test.cluster  2-sample t-test for cluster-randomized observations
./CRAN-contrib/PACKAGES:Package: cluster
./CRAN-contrib/PACKAGES:Description: Functions for cluster analysis, originally from
./CRAN-contrib/PACKAGES:Description: Fuzzy and crisp fixed point cluster analysis
./CRAN-contrib/PACKAGES:Depends: R (>= 1.0), mva, cluster, rpart, combinat
./CRAN-contrib/PACKAGES:Title: 		Model-based cluster analysis
./CRAN-contrib/PACKAGES:Description: 	Model-based cluster analysis: the 2002 version of MCLUST
./CRAN-contrib/PACKAGES:Description: 	Model-based cluster analysis: the 1998 version of MCLUST
./CRAN-contrib/PACKAGES:Title: 		Model-based cluster analysis
./CRAN-contrib/PACKAGES:Description: Summary statistics, generalised linear models, and general maximum pseudolikelihood estimation for stratified, cluster-sampled, unequally weighted survey samples. Variances by Taylor series linearisation or replicate weights
./CRAN-contrib/PACKAGES.html:<a href="#abind">abind</a> <a href="#acepack">acepack</a> <a href="#adapt">adapt</a> <a href="#ade4">ade4</a> <a href="#agce">agce</a> <a href="#akima">akima</a> <a href="#amap">amap</a> <a href="#AnalyzeFMRI">AnalyzeFMRI</a> <a href="#anm">anm</a> <a href="#ape">ape</a> <a href="#ash">ash</a> <a href="#asypow">asypow</a> <a href="#aws">aws</a> <a href="#Bhat">Bhat</a> <a href="#bim">bim</a> <a href="#bindata">bindata</a> <a href="#blighty">blighty</a> <a href="#boolean">boolean</a> <a href="#boot">boot</a> <a href="#bootstrap">bootstrap</a> <a href="#bqtl">bqtl</a> <a href="#brlr">brlr</a> <a href="#car">car</a> <a href="#cat">cat</a> <a href="#cclust">cclust</a> <a href="#CDNmoney">CDNmoney</a> <a href="#cfa">cfa</a> <a href="#CGIwithR">CGIwithR</a> <a href="#chron">chron</a> <a href="#CircStats">CircStats</a> <a href="#classPP">classPP</a> <a href="#clim.pact">clim.pact</a> <a href="#clines">clines</a> <a href="#cluster">cluster</a> <a href="#cmprsk">cmprsk</a> <a href="#cobs">cobs</a> <a href="#CoCoAn">CoCoAn</a> <a href="#coda">coda</a> <a href="#combinat">combinat</a> <a href="#concord">concord</a> <a href="#conf.design">conf.design</a> <a href="#covRobust">covRobust</a> <a href="#cramer">cramer</a> <a href="#DAAG">DAAG</a> <a href="#date">date</a> <a href="#Davies">Davies</a> <a href="#DBI">DBI</a> <a href="#dblcens">dblcens</a> <a href="#deal">deal</a> <a href="#deldir">deldir</a> <a href="#Design">Design</a> <a href="#Devore5">Devore5</a> <a href="#Devore6">Devore6</a> <a href="#diamonds">diamonds</a> <a href="#dichromat">dichromat</a> <a href="#digest">digest</a> <a href="#diptest">diptest</a> <a href="#dispmod">dispmod</a> <a href="#dr">dr</a> <a href="#dse">dse</a> <a href="#e1071">e1071</a> <a href="#effects">effects</a> <a href="#eha">eha</a> <a href="#ellipse">ellipse</a> <a href="#emme2">emme2</a> <a href="#emplik">emplik</a> <a href="#EMV">EMV</a> <a href="#evd">evd</a> <a href="#exactLoglinTest">exactLoglinTest</a> <a href="#exactRankTests">exactRankTests</a> <a href="#fastICA">fastICA</a> <a href="#fda">fda</a> <a href="#fdim">fdim</a> <a href="#fields">fields</a> <a href="#flexmix">flexmix</a> <a href="#foreign">foreign</a> <a href="#fork">fork</a> <a href="#forward">forward</a> <a href="#fpc">fpc</a> <a href="#fracdiff">fracdiff</a> <a href="#ftnonpar">ftnonpar</a> <a href="#g.data">g.data</a> <a href="#gafit">gafit</a> <a href="#gbm">gbm</a> <a href="#gee">gee</a> <a href="#geepack">geepack</a> <a href="#genetics">genetics</a> <a href="#GenKern">GenKern</a> <a href="#geoR">geoR</a> <a href="#geoRglm">geoRglm</a> <a href="#ggm">ggm</a> <a href="#gld">gld</a> <a href="#gllm">gllm</a> <a href="#glmmML">glmmML</a> <a href="#gpclib">gpclib</a> <a href="#grasper">grasper</a> <a href="#GRASS">GRASS</a> <a href="#gregmisc">gregmisc</a> <a href="#gridBase">gridBase</a> <a href="#gss">gss</a> <a href="#gstat">gstat</a> <a href="#gtkDevice">gtkDevice</a> <a href="#haplo.score">haplo.score</a> <a href="#hdf5">hdf5</a> <a href="#HI">HI</a> <a href="#hier.part">hier.part</a> <a href="#Hmisc">Hmisc</a> <a href="#homals">homals</a> <a href="#hwde">hwde</a> <a href="#HyperbolicDist">HyperbolicDist</a> <a href="#ifs">ifs</a> <a href="#ineq">ineq</a> <a href="#ipred">ipred</a> <a href="#ismev">ismev</a> <a href="#ISwR">ISwR</a> <a href="#its">its</a> <a href="#KernSmooth">KernSmooth</a> <a href="#KMsurv">KMsurv</a> <a href="#knnTree">knnTree</a> <a href="#labstatR">labstatR</a> <a href="#lars">lars</a> <a href="#lasso2">lasso2</a> <a href="#lattice">lattice</a> <a href="#lazy">lazy</a> <a href="#ldDesign">ldDesign</a> <a href="#leaps">leaps</a> <a href="#lgtdl">lgtdl</a> <a href="#linprog">linprog</a> <a href="#lme4">lme4</a> <a href="#lmeSplines">lmeSplines</a> <a href="#lmm">lmm</a> <a href="#lmtest">lmtest</a> <a href="#locfit">locfit</a> <a href="#logistf">logistf</a> <a href="#logspline">logspline</a> <a href="#lokern">lokern</a> <a href="#lpridge">lpridge</a> <a href="#lpSolve">lpSolve</a> <a href="#magic">magic</a> <a href="#mapdata">mapdata</a> <a href="#mapproj">mapproj</a> <a href="#maps">maps</a> <a href="#maptools">maptools</a> <a href="#maptree">maptree</a> <a href="#Matrix">Matrix</a> <a href="#maxstat">maxstat</a> <a href="#mclust1998">mclust1998</a> <a href="#mclust">mclust</a> <a href="#MCMCpack">MCMCpack</a> <a href="#mda">mda</a> <a href="#merror">merror</a> <a href="#mgcv">mgcv</a> <a href="#mimR">mimR</a> <a href="#mix">mix</a> <a href="#mlbench">mlbench</a> <a href="#mmlcr">mmlcr</a> <a href="#moc">moc</a> <a href="#MPV">MPV</a> <a href="#msm">msm</a> <a href="#muhaz">muhaz</a> <a href="#multcomp">multcomp</a> <a href="#multidim">multidim</a> <a href="#multiv">multiv</a> <a href="#mvnmle">mvnmle</a> <a href="#mvnormtest">mvnormtest</a> <a href="#mvtnorm">mvtnorm</a> <a href="#ncdf">ncdf</a> <a href="#ncomplete">ncomplete</a> <a href="#negenes">negenes</a> <a href="#netCDF">netCDF</a> <a href="#NISTnls">NISTnls</a> <a href="#nlme">nlme</a> <a href="#nlmeODE">nlmeODE</a> <a href="#nlrq">nlrq</a> <a href="#nor1mix">nor1mix</a> <a href="#norm">norm</a> <a href="#normalp">normalp</a> <a href="#nortest">nortest</a> <a href="#noverlap">noverlap</a> <a href="#npmc">npmc</a> <a href="#nprq">nprq</a> <a href="#Oarray">Oarray</a> <a href="#odesolve">odesolve</a> <a href="#orientlib">orientlib</a> <a href="#oz">oz</a> <a href="#pamr">pamr</a> <a href="#pan">pan</a> <a href="#panel">panel</a> <a href="#pastecs">pastecs</a> <a href="#pcurve">pcurve</a> <a href="#pear">pear</a> <a href="#permax">permax</a> <a href="#pheno">pheno</a> <a href="#phyloarray">phyloarray</a> <a href="#PHYLOGR">PHYLOGR</a> <a href="#pinktoe">pinktoe</a> <a href="#pixmap">pixmap</a> <a href="#pls.pcr">pls.pcr</a> <a href="#polspline">polspline</a> <a href="#polynom">polynom</a> <a href="#pps">pps</a> <a href="#prabclus">prabclus</a> <a href="#princurve">princurve</a> <a href="#pspline">pspline</a> <a href="#psy">psy</a> <a href="#PTAk">PTAk</a> <a href="#qtl">qtl</a> <a href="#quadprog">quadprog</a> <a href="#quantreg">quantreg</a> <a href="#qvcalc">qvcalc</a> <a href="#R2HTML">R2HTML</a> <a href="#RadioSonde">RadioSonde</a> <a href="#RandomFields">RandomFields</a> <a href="#randomForest">randomForest</a> <a href="#RArcInfo">RArcInfo</a> <a href="#Rcmdr">Rcmdr</a> <a href="#RColorBrewer">RColorBrewer</a> <a href="#relimp">relimp</a> <a href="#rgdal">rgdal</a> <a href="#rgenoud">rgenoud</a> <a href="#rimage">rimage</a> <a href="#rmeta">rmeta</a> <a href="#RmSQL">RmSQL</a> <a href="#RMySQL">RMySQL</a> <a href="#RODBC">RODBC</a> <a href="#ROracle">ROracle</a> <a href="#rpart">rpart</a> <a href="#rpvm">rpvm</a> <a href="#rqmcmb2">rqmcmb2</a> <a href="#RQuantLib">RQuantLib</a> <a href="#rsprng">rsprng</a> <a href="#RSQLite">RSQLite</a> <a href="#RSvgDevice">RSvgDevice</a> <a href="#Rwave">Rwave</a> <a href="#sampfling">sampfling</a> <a href="#SASmixed">SASmixed</a> <a href="#sca">sca</a> <a href="#scatterplot3d">scatterplot3d</a> <a href="#seacarb">seacarb</a> <a href="#seao.gui">seao.gui</a> <a href="#seao">seao</a> <a href="#segmented">segmented</a> <a href="#sem">sem</a> <a href="#SenSrivastava">SenSrivastava</a> <a href="#serialize">serialize</a> <a href="#session">session</a> <a href="#sgeostat">sgeostat</a> <a href="#shapefiles">shapefiles</a> <a href="#shapes">shapes</a> <a href="#simpleboot">simpleboot</a> <a href="#sm">sm</a> <a href="#sma">sma</a> <a href="#smoothSurv">smoothSurv</a> <a href="#sn">sn</a> <a href="#sna">sna</a> <a href="#snow">snow</a> <a href="#som">som</a> <a href="#sound">sound</a> <a href="#SparseM">SparseM</a> <a href="#spatstat">spatstat</a> <a href="#spdep">spdep</a> <a href="#splancs">splancs</a> <a href="#StatDataML">StatDataML</a> <a href="#statmod">statmod</a> <a href="#strucchange">strucchange</a> <a href="#subselect">subselect</a> <a href="#SuppDists">SuppDists</a> <a href="#survey">survey</a> <a href="#survival">survival</a> <a href="#survrec">survrec</a> <a href="#systemfit">systemfit</a> <a href="#tapiR">tapiR</a> <a href="#tensor">tensor</a> <a href="#tkrplot">tkrplot</a> <a href="#tree">tree</a> <a href="#tripack">tripack</a> <a href="#tseries">tseries</a> <a href="#udunits">udunits</a> <a href="#VaR">VaR</a> <a href="#vardiag">vardiag</a> <a href="#vcd">vcd</a> <a href="#vegan">vegan</a> <a href="#VLMC">VLMC</a> <a href="#VR">VR</a> <a href="#waveslim">waveslim</a> <a href="#wavethresh">wavethresh</a> <a href="#wle">wle</a> <a href="#xgobi">xgobi</a> <a href="#XML">XML</a> <a href="#xtable">xtable</a> </ul>
./CRAN-contrib/PACKAGES.html:<dt><b><a name="cluster" href="cluster_1.7.6.tar.gz">cluster</a>: Functions for clustering (by Rousseeuw et al.)</b>
./CRAN-contrib/PACKAGES.html:<dd><p>Functions for cluster analysis, originally from
./CRAN-contrib/PACKAGES.html:<a href="Descriptions/cluster.INDEX">Index of Contents</a> (Text)<br>
./CRAN-contrib/PACKAGES.html:<a href="../../doc/packages/cluster.pdf">Reference Manual</a> (PDF)<br>
./CRAN-contrib/PACKAGES.html:<dd><p>Fuzzy and crisp fixed point cluster analysis
./CRAN-contrib/PACKAGES.html:<tr><td valign=top><b>Version:</b></td><td>1.3-3</td></tr><tr><td valign=top><b>Depends:</b></td><td>R (>= 1.0), mva, cluster, rpart, combinat</td></tr><tr><td valign=top><b>Date:</b></td><td>2003/03/06</td></tr><tr><td valign=top><b>Author:</b></td><td>Denis White &lt<a href="mailto:white.denis@epa.gov">white.denis@epa.gov</a>&gt</td></tr><tr><td valign=top><b>Maintainer:</b></td><td>Denis White &lt<a href="mailto:white.denis@epa.gov">white.denis@epa.gov</a>&gt</td></tr><tr><td valign=top><b>License:</b></td><td>Public Domain, unlimited distribution</td></tr><tr><td valign=top><b>URL:</b></td><td><a href="http://www.epa.gov/wed/pages/staff/white/">http://www.epa.gov/wed/pages/staff/white/</a></td></tr></table>
./CRAN-contrib/PACKAGES.html:<dt><b><a name="mclust1998" href="mclust1998_1.1-10.tar.gz">mclust1998</a>: Model-based cluster analysis</b>
./CRAN-contrib/PACKAGES.html:<dd><p>Model-based cluster analysis: the 1998 version of MCLUST
./CRAN-contrib/PACKAGES.html:<dt><b><a name="mclust" href="mclust_2.1-2.tar.gz">mclust</a>: Model-based cluster analysis</b>
./CRAN-contrib/PACKAGES.html:<dd><p>Model-based cluster analysis: the 2002 version of MCLUST
./CRAN-contrib/PACKAGES.html:<dd><p>Summary statistics, generalised linear models, and general maximum pseudolikelihood estimation for stratified, cluster-sampled, unequally weighted survey samples. Variances by Taylor series linearisation or replicate weights
./CRAN-contrib/MAINTAINERS.db:cluster:Martin Maechler <maechler at stat.math.ethz.ch>
./CRAN-contrib/checkSummary.html:<TR> <TD align=right> 84 </TD> <TD align=left>         cluster </TD> <TD align=left>    1.9.0 </TD> <TD align=left> recommended </TD> <TD align=left>                                 Martin Maechler <maechler@stat.math.ethz.ch> </TD> <TD align=left>                                                                                            OK </TD> <TD align=left>                                                                                             </TD> <TD align=left>                                                                                             </TD> <TD align=left>                  </TD> </TR>
./CRAN-contrib/checkSummary.html:<TR> <TD align=right> 85 </TD> <TD align=left>         cluster </TD> <TD align=left>    1.7.6 </TD> <TD align=left> recommended </TD> <TD align=left>                                 Martin Maechler <maechler@stat.math.ethz.ch> </TD> <TD align=left>                                                                                               </TD> <TD align=left>    <a href="http://www.R-project.org/nocvs/R.check/r-patched/cluster-00check.txt">ERROR</a> </TD> <TD align=left>                                                                                          OK </TD> <TD align=left>                  </TD> </TR>
./survey/man/api.Rd: \code{clus1} is a cluster sample of school districts, \code{strat} is
./survey/man/api.Rd:  cluster sample of schools within districts.
./survey/man/api.Rd:# one-stage cluster sample
./survey/man/api.Rd:# two-stage cluster sample
./survey/man/as.svrepdesign.Rd:  strata/cluster survey design object.
./survey/man/brrweights.Rd:  \item{psu}{PSU (cluster) identifier }
./survey/man/svrepdesign.Rd:  cluster at a time. JKn is designed for stratified and JK1 for
./survey/man/svycoxph.Rd:Fit a generalised linear model to data from a complex survey design, with inverse-probability weighting and with standard errors corrected for cluster sampling.
./survey/man/svycoxph.Rd:  \item{formula}{Model formula. Any \code{cluster()} terms will be ignored.}
./survey/man/svyCprod.Rd:  \item{psu}{A vector of cluster indicators or \code{NULL}}
./survey/man/svyCprod.Rd: The observations for each cluster are added, then centred within each
./survey/man/svyCprod.Rd: each cluster.  This is added within strata, multiplied by a
./survey/man/svydesign.Rd:  \item{ids}{Formula or data frame specifying cluster ids from largest
./survey/man/svydesign.Rd:  \item{probs}{Formula or data frame specifying cluster sampling probabilities}
./survey/man/svydesign.Rd:  \item{nest}{If \code{TRUE}, relabel cluster ids to enforce nesting, eg
./survey/man/svydesign.Rd:   of stratification and of correlation induced by cluster sampling must
./survey/man/svydesign.Rd:to strata containing only one cluster (PSU).See \code{\link{svyCprod}}
./survey/man/svydesign.Rd:# one-stage cluster sample
./survey/man/svydesign.Rd:# two-stage cluster sample
./survey/man/svydesign.Rd:## syntax for stratified cluster sample
./survey/man/svyglm.Rd:Fit a generalised linear model to data from a complex survey design, with inverse-probability weighting and with standard errors corrected for cluster sampling.
./survey/man/svyglm.Rd:In \code{svyglm}, standard errors for cluster-sampled designs are computed using a
./survey/man/svyquantile.Rd:  ## one-stage cluster sample
./survey/R/survey.R:    rval<-list(cluster=ids)
./survey/R/survey.R:  n<-NROW(x$cluster)
./survey/R/survey.R:  un<-length(unique(x$cluster[,1]))
./survey/R/survey.R:    cat(NCOL(x$cluster),"- level Cluster Sampling design\n")
./survey/R/survey.R:    nn<-lapply(x$cluster,function(i) length(unique(i)))
./survey/R/survey.R:               table(x$strata[!duplicated(x$cluster[,1])]))
./survey/R/survey.R:    x$cluster<-x$cluster[i,,drop=FALSE]
./survey/R/survey.R:    object$cluster<-object$cluster[-omit,,drop=FALSE]
./survey/R/survey.R:	   object$cluster<-object$cluster[-exclude,,drop=FALSE]
./survey/R/survey.R:      ## stratum with only 1 cluster leads to undefined variance
./survey/R/survey.R:	v<-svyCprod(x*pweights/psum,design$strata,design$cluster[[1]], design$fpc, design$nPSU)
./survey/R/survey.R:  attr(total, "var")<-svyCprod(x/design$prob,design$strata, design$cluster[[1]], design$fpc, design$nPSU)
./survey/R/survey.R:        vars[i,j]<-svyCprod(r*1/design$prob, design$strata, design$cluster[[1]], design$fpc, design$nPSU)
./survey/R/survey.R:                    design$cluster[[1]], design$fpc,design$nPSU)
./survey/R/survey.R:    B<-svyCprod(estfun,design$strata,design$cluster[[1]],design$fpc, design$nPSU)
./survey/R/surveyrep.R:    r<-jk1weights(design$cluster[,1], fpc=fpc,fpctype=fpctype)
./survey/R/surveyrep.R:    r<-brrweights(design$strata, design$cluster[,1])
./survey/R/surveyrep.R:    r<-jknweights(design$strata,design$cluster[,1], fpc=fpc,fpctype=fpctype)
./survey/R/surveyrep.R:    cat("Unstratified cluster jacknife (JK1) ")
./survey/R/surveyrep.R:    cat("Stratified cluster jackknife (JKn) ")
./survey/NEWS:       as.svrepdesign wasn't handling unstratified cluster samples right.
./survey/NEWS:	- Bug in handling multiple levels of cluster id in svydesign
./survey/DESCRIPTION:Description: Summary statistics, generalised linear models, and general maximum pseudolikelihood estimation for stratified, cluster-sampled, unequally weighted survey samples. Variances by Taylor series linearisation or replicate weights
./prabclus/man/summary.prabtest.Rd:\keyword{cluster}% at least one, from doc/KEYWORDS
./prabclus/man/concomp.Rd:\keyword{cluster}% __ONLY ONE__ keyword per line
./prabclus/man/lcomponent.Rd:\keyword{cluster}% at least one, from doc/KEYWORDS
./prabclus/man/distratio.Rd:\keyword{cluster}% at least one, from doc/KEYWORDS
./prabclus/man/jaccard.Rd:\keyword{cluster}% at least one, from doc/KEYWORDS
./prabclus/man/prabtest.Rd:\keyword{cluster}% at least one, from doc/KEYWORDS
./prabclus/man/homogen.test.Rd:  Ling, R. F. (1973) A probability theory of cluster
./prabclus/man/homogen.test.Rd:\keyword{cluster}% at least one, from doc/KEYWORDS
./prabclus/man/prabinit.Rd:\keyword{cluster}% __ONLY ONE__ keyword per line
./prabclus/man/conregmat.Rd:\keyword{cluster}% __ONLY ONE__ keyword per line
./prabclus/man/prabclust.Rd:  \item{clustering}{vector of integers indicating the cluster memberships of
./prabclus/man/prabclust.Rd:\keyword{cluster}% at least one, from doc/KEYWORDS
./prabclus/man/kulczynski.Rd:\keyword{cluster}% at least one, from doc/KEYWORDS
./prabclus/man/nn.Rd:\keyword{cluster}% at least one, from doc/KEYWORDS
./prabclus/man/NNclean.Rd:  Detects if data points are noise or part of a cluster,
./prabclus/man/NNclean.Rd:  subregion (disconnected in case of more than one cluster).
./prabclus/man/NNclean.Rd:  EM-algorithm. The points are assigned to noise or cluster component
./prabclus/man/NNclean.Rd:    cluster, 0 means noise.}
./prabclus/man/NNclean.Rd:    to belong to the cluster component.}
./prabclus/man/NNclean.Rd:  \item{lambda1}{intensity parameter of cluster component.}
./prabclus/man/NNclean.Rd:  \item{p}{estimated probability of cluster component.}
./prabclus/man/NNclean.Rd:\keyword{cluster}% __ONLY ONE__ keyword per line
./prabclus/man/pop.sim.Rd:\keyword{cluster}% at least one, from doc/KEYWORDS
./prabclus/R/NNclean.R:# z will be the classifications. 1= in cluster. 0= in noise.
./amap/R/hclust.R:        stop("Must have n >= 2 objects to cluster")
./amap/R/hclust.R:## For S ``compatibility'': was in cluster just as
./amap/R/hcluster.R:        stop("Must have n >= 2 objects to cluster")
./amap/man/dist.Rd:  \code{\link[cluster]{daisy}} in the \file{cluster} package with more
./amap/man/dist.Rd:\keyword{cluster}
./amap/man/hclust.Rd:  Hierarchical cluster analysis on a set of dissimilarities and
./amap/man/hclust.Rd:    was with the cluster formed at the (earlier) stage \eqn{j}
./amap/man/hclust.Rd:    observations suitable for plotting, in the sense that a cluster
./amap/man/hclust.Rd:  \item{method}{the cluster method that has been used.}
./amap/man/hclust.Rd:  This function performs a hierarchical cluster analysis
./amap/man/hclust.Rd:  cluster and then the algorithm proceeds iteratively,
./amap/man/hclust.Rd:  continuing until there is just a single cluster.
./amap/man/hclust.Rd:  per cluster. This way the hierarchical cluster algorithm can be ``started
./amap/man/hclust.Rd:  the squared Euclidean distances between cluster means.
./amap/man/hclust.Rd:  In hierarchical cluster displays, a decision is needed at each merge to
./amap/man/hclust.Rd:  in a cluster tree, or dendrogram.
./amap/man/hclust.Rd:  the tighter cluster is on the left (the last, i.e. most recent,
./amap/man/hclust.Rd:## tree from the cluster centers.
./amap/man/hclust.Rd:\keyword{cluster}
./amap/man/hcluster.Rd:  Hierarchical cluster analysis.
./amap/man/hcluster.Rd:    was with the cluster formed at the (earlier) stage \eqn{j}
./amap/man/hcluster.Rd:    observations suitable for plotting, in the sense that a cluster
./amap/man/hcluster.Rd:  \item{method}{the cluster method that has been used.}
./amap/man/hcluster.Rd:## tree from the cluster centers.
./amap/man/hcluster.Rd:\keyword{cluster}
./amap/src/hclust.c: *                     cluster cardinalities, current nearest
./amap/src/hclust.c:       * Update dissimilarities from new cluster.
./amap/src/hclust.c:/*  cluster assignments at all levels, at extra comput. expense*/
./R2HTML/R/R2HTML.R:    HTML("<P>\nNumerical information per cluster:\n</P>",file=file)
./R2HTML/R/R2HTML.R:        HTML("<P>Average silhouette width per cluster:\n</P>",file=file)
./R2HTML/R/R2HTML.R:        HTML("<P>Average silhouette width per cluster:\n</P>",file=file)
./R2HTML/R/R2HTML.R:    HTML("<P>\nNumerical information per cluster:\n</P>",file=file)
./R2HTML/R/R2HTML.R:        HTML("<P>Average silhouette width per cluster:\n</P>",file=file)
./Hmisc/R/Hmisc.R:deff <- function(y, cluster)	{
./Hmisc/R/Hmisc.R:if(!is.factor(cluster)) cluster <- as.factor(cluster)
./Hmisc/R/Hmisc.R:cluster <- oldUnclass(cluster)
./Hmisc/R/Hmisc.R:s <- !is.na(cluster+y)
./Hmisc/R/Hmisc.R:y <- y[s]; cluster <- as.integer(cluster[s])
./Hmisc/R/Hmisc.R:sses <- tapply(y,cluster,ss)
./Hmisc/R/Hmisc.R:ng <- table(cluster)
./Hmisc/R/Hmisc.R:t.test.cluster <- function(y, cluster, group, conf.int=.95)    		{
./Hmisc/R/Hmisc.R:cluster <- as.factor(cluster)
./Hmisc/R/Hmisc.R:s <- !(is.na(y)|is.na(cluster)|is.na(group))
./Hmisc/R/Hmisc.R:y <- y[s];  cluster <- cluster[s];  group <- group[s]
./Hmisc/R/Hmisc.R:nc <- tapply(cluster, group, function(x)length(unique(x)))
./Hmisc/R/Hmisc.R:c1 <- factor(cluster[u==1]); c2 <- factor(cluster[u==2]) #factor rids unused lev
./Hmisc/R/Hmisc.R:	"Variance without cluster adjustment","Design Effect",
./Hmisc/R/Hmisc.R:attr(stats,'class') <- "t.test.cluster"
./Hmisc/R/Hmisc.R:print.t.test.cluster <- function(x, digits, ...) {
./Hmisc/man/rm.boot.Rd:subject's data will appear in a bootstrap sample.  This cluster
./Hmisc/man/Overview.Rd:deff            \tab Kish design effect and intra-cluster correlation\cr
./Hmisc/man/Overview.Rd:t.test.cluster  \tab 2-sample t-test for cluster-randomized observations\cr
./Hmisc/man/dataRep.Rd:\keyword{cluster}
./Hmisc/man/deff.Rd:Design Effect and Intra-cluster Correlation
./Hmisc/man/deff.Rd:Computes the Kish design effect and corresponding intra-cluster correlation
./Hmisc/man/deff.Rd:for a single cluster-sampled variable
./Hmisc/man/deff.Rd:deff(y, cluster)
./Hmisc/man/deff.Rd:\item{cluster}{
./Hmisc/man/deff.Rd:a variable whose unique values indicate cluster membership.  Any
./Hmisc/man/deff.Rd:(intra-cluster correlation), and \code{deff} (design effect).
./Hmisc/man/t.test.cluster.Rd:\name{t.test.cluster}
./Hmisc/man/t.test.cluster.Rd:\alias{t.test.cluster}
./Hmisc/man/t.test.cluster.Rd:\alias{print.t.test.cluster}
./Hmisc/man/t.test.cluster.Rd:t.test.cluster(y, cluster, group, conf.int = 0.95)
./Hmisc/man/t.test.cluster.Rd:\method{print}{t.test.cluster}(x, digits, \dots)
./Hmisc/man/t.test.cluster.Rd:  \item{cluster}{cluster identifiers, e.g. subject ID}
./Hmisc/man/t.test.cluster.Rd:  \item{x}{an object created by \code{t.test.cluster}}
./Hmisc/man/t.test.cluster.Rd:  a matrix of statistics of class \code{t.test.cluster}
./Hmisc/man/t.test.cluster.Rd:table(cluster,group)
./Hmisc/man/t.test.cluster.Rd:t.test.cluster(y, cluster, group)
./Hmisc/man/t.test.cluster.Rd:# compare with t.test.cluster
./Hmisc/man/varclus.Rd:Does a hierarchical cluster analysis on variables, using the Hoeffding
./Hmisc/man/varclus.Rd:\keyword{cluster}
./Hmisc/INDEX:deff            Kish design effect and intra-cluster correlation
./Hmisc/INDEX:t.test.cluster  2-sample t-test for cluster-randomized observations
./VR/MASS/inst/scripts/ch11.R:library(cluster)
./VR/MASS/inst/scripts3/ch11.R:plot(h) # or plclust with library(cluster)
./VR/MASS/inst/scripts3/ch11.R:library(cluster)
./VR/MASS/inst/scripts3/ch11.R:table(crabs$sp, crabs.km$cluster)
./nlme/R/lme.R:  ##  in the original data are collapsed over the cluster variable by the
./nlme/R/lmList.R:  ##  in the original data are collapsed over the cluster variable by the
./multidim/R/fmultidim0107.R:	resf$cluster
./multidim/R/fmultidim0107.R:#             $cluster          la partition stabilisee
./multidim/R/fmultidim0107.R:	list(cluster = p, centers = cntr, withinss = withinss(x, p, wt), size
./multidim/R/fmultidim0107.R:	pds <- tapply(wt, p1$cluster, sum)	# poids des nc noyaux
./multidim/R/fmultidim0107.R:	partinit <- part[p1$cluster]	# partition de l'étape 2 sur
./multidim/R/fmultidim0107.R:	list(p1 = p1$cluster, p2 = partinit, p3 = partfinal, p2n = p2n)
./multidim/R/fmultidim0107.R:			clust[, j, i] <- reskm$cluster
./multidim/R/fmultidim0107.R:			intx[i, j] <- interx(x, reskm$cluster)
./multidim/R/fmultidim0107.R:#                 ou encore partition au format S : p$cluster contient
./multidim/R/fmultidim0107.R:	if(!is.null(p$cluster))
./multidim/R/fmultidim0107.R:		p <- p$cluster
./multidim/R/fmultidim0107.R:			clust[, j, i] <- reskm$cluster
./multidim/R/fmultidim0107.R:			intx[i, j] <- interx(x, reskm$cluster)
./multidim/R/fmultidim0107.R:	#			indiso(list(cmpr = x), pltcl = reskm$cluster)
./multidim/man/forgy.Rd:             $cluster          la partition stabilisee
./multidim/man/discriaff.Rd:\keyword{cluster}
./multidim/man/gravc.Rd:#resforgy$cluster est la partition améliorée.
./multidim/inst/doc/multidim.ps:(individus)f(dans)i(les)f(classes)g(\($cluster\),)g(les)f(cen)o(tres)g
./multidim/inst/doc/multidim.ps:(app)q(elle)h(le)f(comp)q(osan)o(t)g Fi($cluster)f Fo(des)j(r)o(\023)
./do-untar+install:##             $pkg != ash -a $pkg != cluster -a \
./do-untar+install:## ash, cluster, ... fail to link on Solaris !!
./e1071/R/bclust.R:                  cluster = NULL,
./e1071/R/bclust.R:            stop("Could not find valid cluster solution in 20 replications\n")
./e1071/R/bclust.R:        if (!require("cluster")) stop("Could not load required package cluster")
./e1071/R/bclust.R:    object$cluster <- clusters.bclust(object, centers)
./e1071/R/bclust.R:        object$cluster <- kmeansres$cluster
./e1071/R/cmeans.R:  retval <- list(centers = centers, size = clustersize, cluster = clusterU,
./e1071/R/cmeans.R:#  cluster <- integer(xrows)
./e1071/R/cmeans.R:#    stop("Number of variables in cluster object and x are not the same!")
./e1071/R/cmeans.R:#  clobj$cluster <- clusterU
./e1071/R/cshell.R:                 size = clustersize, cluster = clusterU,
./e1071/R/cshell.R:#  cluster <- integer(xrows)
./e1071/R/cshell.R:#    stop("Number of variables in cluster object and x are not the same!")
./e1071/R/cshell.R:#  clobj$cluster <- clusterU
./e1071/NEWS:    kmeans gives an error when a cluster becomes empty (which can
./e1071/man/bclust.Rd:  \item{iter.base}{Number of runs of the base cluster algorithm.}
./e1071/man/bclust.Rd:  \item{minsize}{Minimum number of points in a base cluster.}
./e1071/man/bclust.Rd:  \item{base.method}{Partitioning cluster method used as base algorithm.}
./e1071/man/bclust.Rd:    algorithm. A partitioning cluster algorithm such as
./e1071/man/bclust.Rd:    original data. The resulting cluster centers are then combined using
./e1071/man/bclust.Rd:    the hierarchical cluster algorithm \code{\link{hclust}}.
./e1071/man/bclust.Rd:    \code{x} are created by drawing with replacement. The base cluster
./e1071/man/bclust.Rd:    cluster function returning a list with the same components as the
./e1071/man/bclust.Rd:    with standard partitioning cluster methods such as
./e1071/man/bclust.Rd:    \item{cluster}{Vector with indices of the clusters the inputs are
./e1071/man/bclust.Rd:\keyword{cluster}
./e1071/man/boxplot.bclust.Rd:\title{Boxplot of cluster profiles}
./e1071/man/boxplot.bclust.Rd: \item{bycluster}{If \code{TRUE} (default), a boxplot for each cluster
./e1071/man/boxplot.bclust.Rd: \item{main}{Main title of the plot, by default the name of the cluster
./e1071/man/classAgreement.Rd:cluster analysis on the same data set), then the situation is a little
./e1071/man/classAgreement.Rd:points which are either put into the same cluster by both partitions or
./e1071/man/classAgreement.Rd:cluster in one partition, but into different clusters by the other
./e1071/man/cmeans.Rd:  \item{centers}{Number of clusters or initial values for cluster centers}
./e1071/man/cmeans.Rd:  If \code{centers} is a matrix, its rows are taken as the initial cluster
./e1071/man/cmeans.Rd:  cluster center and the data points is the Euclidean distance (ordinary
./e1071/man/cmeans.Rd:  between the cluster center and the data points is the sum of the
./e1071/man/cmeans.Rd:  \item{centers}{The final cluster centers.}
./e1071/man/cmeans.Rd:  \item{size}{The number of data points in each cluster.}
./e1071/man/cmeans.Rd:  \item{cluster}{Vector containing the indices of the clusters where
./e1071/man/cmeans.Rd:    point is considered for partitioning it to a cluster.}
./e1071/man/cmeans.Rd:\keyword{cluster}
./e1071/man/cshell.Rd:  \item{centers}{Number of clusters or initial values for cluster centers}
./e1071/man/cshell.Rd:  If \code{centers} is a matrix, its rows are taken as the initial cluster
./e1071/man/cshell.Rd:  cluster center and the data points is the Euclidean distance (ordinary
./e1071/man/cshell.Rd:  cluster center and the data points is the sum of the absolute values
./e1071/man/cshell.Rd:  cluster.
./e1071/man/cshell.Rd:  \item{centers}{The final cluster centers.}
./e1071/man/cshell.Rd:  \item{size}{The number of data points in each cluster.}
./e1071/man/cshell.Rd:  \item{cluster}{Vector containing the indices of the clusters where
./e1071/man/cshell.Rd:    point is considered for partitioning it to a cluster.}
./e1071/man/cshell.Rd:\keyword{cluster}
./e1071/man/fclustIndex.Rd:    vicinity of the cluster centroids. These indexes are only for the
./e1071/man/fclustIndex.Rd:    in the partition matrix as it becomes more fuzzier. A crisp cluster
./e1071/man/fclustIndex.Rd:    This index identifies unique cluster structure with well-defined
./e1071/man/fclustIndex.Rd:\keyword{cluster}
./e1071/man/lca.Rd:\keyword{cluster}
./e1071/INDEX:boxplot.bclust          Boxplot of cluster profiles
./flexmix/R/flexmix.R:                        cluster="integer",
./flexmix/R/flexmix.R:    print(table(object@cluster))
./flexmix/R/flexmix.R:           function(formula, data=list(), k=NULL, cluster=NULL,
./flexmix/R/flexmix.R:function(formula, data=list(), k=NULL, cluster=NULL,
./flexmix/R/flexmix.R:    z <- flexmix(formula=formula, data=data, k=k, cluster=cluster,
./flexmix/R/flexmix.R:function(formula, data=list(), k=NULL, cluster=NULL,
./flexmix/R/flexmix.R:    z = FLXfit(model=model, control=control, k=k, cluster=cluster)
./flexmix/R/flexmix.R:function(formula, data=list(), k=NULL, cluster=NULL,
./flexmix/R/flexmix.R:    z <- flexmix(formula=formula, data=data, k=k, cluster=cluster,
./flexmix/R/flexmix.R:FLXfit <- function(k=NULL, cluster=NULL, model, control)
./flexmix/R/flexmix.R:    if(is.null(cluster)){
./flexmix/R/flexmix.R:            stop("either k or cluster must be specified")
./flexmix/R/flexmix.R:        cluster <- as(cluster, "integer")
./flexmix/R/flexmix.R:        k <- max(cluster)
./flexmix/R/flexmix.R:        postscaled[cluster==K, K] <- 0.9
./flexmix/R/flexmix.R:                   cluster=apply(postscaled,1,which.max),
./flexmix/man/FLXfit.Rd:FLXfit(k = NULL, cluster = NULL, model, control)
./flexmix/man/FLXfit.Rd:  \item{k}{Number of clusters (not needed if \code{cluster} is specified).}
./flexmix/man/FLXfit.Rd:  \item{cluster}{Initial cluster assignments of observations at the
./flexmix/man/FLXfit.Rd:\keyword{cluster}
./flexmix/man/FLXmclust.Rd:\keyword{cluster}
./flexmix/man/FLXmclust.Rd:    eqscplot(data, col=object@cluster)
./flexmix/man/flexmix-class.Rd:      and one column per cluster.}
./flexmix/man/flexmix-class.Rd:    \item{\code{cluster}:}{Cluster assignments of observations.}
./flexmix/man/flexmix.Rd:flexmix(formula, data = list(), k = NULL, cluster = NULL,
./flexmix/man/flexmix.Rd:  \item{k}{Number of clusters (not needed if \code{cluster} is specified).}
./flexmix/man/flexmix.Rd:  \item{cluster}{Factor or integer vector with the initial cluster
./flexmix/man/flexmix.Rd:\keyword{cluster}
./flexmix/man/flexmix.Rd:table(ex.qpol1@cluster, mydf$class)
./sca/R/sca.R:		cluster = c("median","single","complete"),
./sca/R/sca.R:  ## cluster="single" for "single linkage clustering"
./sca/R/sca.R:  ## cluster="median" for "median linkage clustering"
./sca/R/sca.R:  ## cluster="complete" for "complete linkage clustering"
./sca/R/sca.R:  cluster <- match.arg(cluster)
./sca/R/sca.R:      P[[I+1]] <- agglomblock(S,P[[I]],cluster)
./sca/R/sca.R:        P[[I+1]] <- agglomblock(S,P[[I]],cluster)
./sca/R/sca.R:	P[[J]] <- agglomblock(S,Ptmp,cluster)
./sca/R/sca.R:	    cluster  = cluster,
./sca/R/sca.R:agglomblock <- function(S, P, cluster = c("median","single","complete"))
./sca/R/sca.R:## agglomerate the two block-components according to cluster
./sca/R/sca.R:  cluster <- match.arg(cluster)
./sca/R/sca.R:	  switch(cluster,
./sca/R/sca.R:  catn("Clustering procedure        :",paste(x$cluster,"linkage"))
./sca/man/sca.Rd:    criterion = c("csv", "blp"), cluster = c("median","single","complete"),
./sca/man/sca.Rd:  \item{cluster}{character string specifying the clustering method to be
./sca/man/sca.Rd:  \item{cluster}{as above.}
./sca/man/agglomblock.Rd:  according to the specified \code{cluster}ing method.
./sca/man/agglomblock.Rd:agglomblock(S, P, cluster = c("median","single","complete"))
./sca/man/agglomblock.Rd:  \item{cluster}{character specifying the clustering method; default
./sca/man/agglomblock.Rd:    \code{"median"}, see \code{\link{sca}(*, cluster=)}.}
./sca/tests/3ex.Rout.save:> sca(hearlossC, cluster = "single")
./sca/tests/3ex.Rout.save:> sca(reflexesC, cluster = "complete")
./sca/tests/3ex.Rout.save:> sca(reflexesC, qmin = 4, b = 3, corblocks = 0, cluster = "single")
./sca/tests/3ex.Rout.save:> sca(pitpropC, cluster = "single")
./sca/tests/3ex.R:sca(hearlossC, cluster = "single")
./sca/tests/3ex.R:sca(reflexesC, cluster = "complete")
./sca/tests/3ex.R:sca(reflexesC, qmin = 4, b = 3, corblocks = 0, cluster = "single")
./sca/tests/3ex.R:sca(pitpropC, cluster = "single")
./sca/tests/artif3.Rout.save: $ cluster    : chr "median"
./sca/tests/artif3.Rout.save: $ cluster    : chr "median"
./som/man/som.Rd:\keyword{cluster}
./maptools/R/colslegs.R:#o <- order(matrix(unlist(tapply(x, k4$cluster, range)), ncol=2, byrow=TRUE)[,1])
./maptools/R/colslegs.R:#barplot(table(k4$cluster)[o])
./maptools/R/colslegs.R:#unlist(tapply(x, rev(order(k4$centers))[k4$cluster], range))
./maptools/R/colslegs.R:#matrix(unlist(tapply(x, rev(order(k4$centers))[k4$cluster], range)), 4, 2, byrow=TRUE)
./maptools/R/colslegs.R:#by(x, rev(order(k4$centers))[k4$cluster], range)
./Design/R/Design.R:#23Feb95 - added logic to remove cluster() factors
./Design/R/Design.R:iscluster <- if(length(Term.labels)) substring(Term.labels,1,8)=='cluster('
./Design/R/Design.R:bootcov <- function(fit, cluster, B=200, fitter, coef.reps=FALSE,
./Design/R/Design.R:##  if(!missing(cluster))  15nov02
./Design/R/Design.R:##    stop('group is currently allowed only when cluster is not given')
./Design/R/Design.R:if(missing(cluster))						{
./Design/R/Design.R:   if(length(cluster) > n)		{
./Design/R/Design.R:        cluster <- cluster[j]
./Design/R/Design.R:   if(length(cluster)!=n) stop("length of cluster does not match # rows used in fit")
./Design/R/Design.R:   if(any(is.na(cluster))) stop("cluster contains NAs")
./Design/R/Design.R:   cluster <- as.character(cluster)
./Design/R/Design.R:   clusters <- unique(cluster)
./Design/R/Design.R:##   q <- as.vector(t(matrix(rep(cluster, nx), ncol=nx)))
./Design/R/Design.R:##   q <- as.vector(t(matrix(rep(cluster, ny), ncol=ny)))
./Design/R/Design.R:##   if(str.pres) str <- split(str, cluster)
./Design/R/Design.R:          cluster.gi <- cluster[gi]
./Design/R/Design.R:          clusters.gi <- unique(cluster.gi)
./Design/R/Design.R:          Obsno.gci <- split(gi, cluster.gi)
./Design/R/Design.R:                                     specials=c("strat","cluster")) else
./Design/R/Design.R:          specials=c("strat","cluster"), data=data)
./Design/R/Design.R:    cluster <- attr(Terms, "specials")$cluster
./Design/R/Design.R:    if(length(cluster)) {
./Design/R/Design.R:      cluster <- strata(X[,tempc$vars], shortlabel=TRUE)  #allow multiples
./Design/R/Design.R:    if(missing(cluster)) cluster <- FALSE
./Design/R/Design.R:    temp <- residuals.coxph(fit2, type='dfbeta', collapse=cluster)
./Design/R/Design.R:		non.slopes.in.x=TRUE, kint=1, cluster, subset, group=NULL, ...) {
./Design/R/Design.R:multi <- !missing(cluster)   # some subjects have multiple records now
./Design/R/Design.R:    stop('group is currently allowed only when method="boot" and cluster is not given')
./Design/R/Design.R:  if(method!='boot') stop('cluster only implemented for method="boot"')
./Design/R/Design.R:  if(length(cluster) > n) {
./Design/R/Design.R:	  cluster <- cluster[j]
./Design/R/Design.R:  if(length(cluster) != n)
./Design/R/Design.R:	stop('length of cluster does not match # rows used in fit')
./Design/R/Design.R:  if(any(is.na(cluster))) stop('cluster has NAs')
./Design/R/Design.R:  n.orig <- length(unique(cluster))
./Design/R/Design.R:    special <- c("strata", "cluster")
./Design/R/Design.R:    cluster<- attr(Terms, "specials")$cluster
./Design/R/Design.R:    if (length(cluster)) {
./Design/R/Design.R:        cluster <- strata(m[,tempc$vars], shortlabel=TRUE)  #allow multiples
./Design/R/Design.R:robcov <- function(fit, cluster, method=c('huber','efron')) {
./Design/R/Design.R:else if(any(is.na(cluster))) stop("cluster contains NAs")
./Design/R/Design.R:if(length(cluster)!=n)
./Design/R/Design.R: stop("length of cluster does not match number of observations used in fit")
./Design/R/Design.R:cluster <- as.factor(cluster)
./Design/R/Design.R:  cluster <- cluster[!j]
./Design/R/Design.R:  n <- length(cluster)
./Design/R/Design.R:j <- order(cluster)
./Design/R/Design.R:clus.size <- table(cluster)
./Design/R/Design.R:nc <- length(levels(cluster))
./Design/R/Design.R:#W <- tapply(X,list(cluster[row(X)],col(X)),sum)
./Design/R/Design.R:#for(j in levels(cluster))		{
./Design/R/Design.R:#   s <- cluster==j
./Design/man/Overview.Rd:  for cluster sampling
./Design/man/bootcov.Rd:bootstrap estimates corrected for cluster sampling (intra-cluster
./Design/man/bootcov.Rd:cluster sampling with replacement for the usual simple sampling with
./Design/man/bootcov.Rd:bootcov(fit, cluster, B=200, fitter,
./Design/man/bootcov.Rd:\item{cluster}{
./Design/man/bootcov.Rd:a variable indicating groupings. \code{cluster} may be any type of vector
./Design/man/bootcov.Rd:Unique values of \code{cluster} indicate
./Design/man/bootcov.Rd:coincide with \code{cluster}.
./Design/man/bootcov.Rd:You may specify both \code{group} and \code{cluster}.
./Design/man/bootcov.Rd:anova(g)            # cluster-adjusted Wald statistics
./Design/man/bootcov.Rd:# fastbw(g)         # cluster-adjusted backward elimination
./Design/man/calibrate.Rd:\code{cluster}, and \code{subset}.
./Design/man/cph.Rd:model includes a \code{cluster()} operative, \code{FALSE} otherwise.
./Design/man/cr.setup.Rd:which pass this vector under the name \code{cluster} on to \code{predab.resample} so that bootstrapping can be
./Design/man/cr.setup.Rd:cal <- calibrate(g, cluster=u$subs, subset=cohort=='all')
./Design/man/glsD.Rd:   one large cluster when fitting using the \code{gls} algorithm}
./Design/man/glsD.Rd:  make it easy to use with the Design library and to implement cluster
./Design/man/ie.setup.Rd:which pass this vector under the name \code{cluster} on to \code{predab.resample} so that bootstrapping can be
./Design/man/predab.resample.Rd:                cluster, subset, group=NULL, \dots)
./Design/man/predab.resample.Rd:\item{cluster}{
./Design/man/predab.resample.Rd:Vector containing cluster identifiers.  This can be specified only if
./Design/man/predab.resample.Rd:\code{fit.orig} to conform \code{cluster} to the data.
./Design/man/robcov.Rd:heteroscedasticity and for correlated responses from cluster samples.
./Design/man/robcov.Rd:For the special case where every cluster contains one observation, the
./Design/man/robcov.Rd:robcov(fit, cluster, method=c('huber','efron'))
./Design/man/robcov.Rd:\item{cluster}{
./Design/man/robcov.Rd:a variable indicating groupings. \code{cluster} may be any type of vector
./Design/man/robcov.Rd:Unique values of \code{cluster} indicate
./Design/man/robcov.Rd:with \code{cluster}.
./Design/man/robcov.Rd:If \code{cluster} is omitted,
./Design/man/robcov.Rd:anova(g)            # cluster-adjusted Wald statistics
./Design/man/robcov.Rd:# fastbw(g)         # cluster-adjusted backward elimination
./Design/man/validate.Rd:pass to \code{predab.resample} (note especially the \code{group}, \code{cluster}, amd \code{subset} parameters).
./Design/man/validate.lrm.Rd:\code{cluster}, and \code{subset} parameters)
./Design/man/validate.lrm.Rd:validate(f, cluster=u$subs, subset=cohort=='all')
./Design/man/validate.lrm.Rd:#see predab.resample for cluster and subset
./Design/man/validate.ols.Rd:other arguments to pass to \code{predab.resample}, such as \code{group}, \code{cluster}, and \code{subset}
./Design/src/robcovf.r:# Computes sum of (within cluster sum of U)(within cluster sum of U)'
./gridBase/inst/doc/gridBase.Snw:subtrees\footnote{the data and cluster analysis are copied from the example
./gridBase/inst/doc/gridBase.tex:subtrees\footnote{the data and cluster analysis are copied from the example

./smoothSurv/R/smoothSurvReg.R:   special <- c("strata", "cluster", "frailty")
./smoothSurv/R/smoothSurvReg.R:   ## Neither strata nor cluster nor frailties are allowed.
./smoothSurv/R/smoothSurvReg.R:   if(!is.null(attr(Terms,"specials")$cluster)){

./Rmpi/inst/Rprofile:#This R profile is used when a cluster does not allow spawning or a job
./Rmpi/man/mpi.spawn.Rslaves.Rd:total CPUs available in a cluster.
./Rmpi/man/mpi.universe.size.Rd:cluster. Some MPI implements may not have this MPI call available.
./Rmpi/README:are tested) at present. A Beowulf cluster should be set up properly before
./Rmpi/README:   and CPU numbers per host in a cluster. A remote shell program such as
./Rmpi/README:   Notice that LAM-MPI must be installed on all hosts within a cluster.
./Rmpi/README:   If your cluster does not have MPI_Comm_spawn enabled (UWO sharcnet
./Rmpi/README:   Notice that R and Rmpi have to be installed on all hosts in a cluster. The
./Rmpi/README:   cluster otherwise Rmpi may have difficult to spawn R slaves. Using a NFS
./Rmpi/README:   cluster of computers.
./Rmpi/README:   file. If some MPI functions are not available on your cluster, you need
./Rmpi/README:   Make sure R is in the PATH for whole cluster. Try
./ape_virgin/Changes:      "hclust" cluster objects and vice versa (see the help page of
./ape_virgin/man/klastorin.Rd:   using hierarchical cluster analysis. \emph{Operations Research} \bold{30},1134--1147.
./ape.Rcheck/ape/man/ape.Rd:   using hierarchical cluster analysis. \emph{Operations Research} \bold{30},1134--1147.
./ape.Rcheck/ape/help/klastorin:     determination using hierarchical cluster analysis. _Operations
./ape.Rcheck/ape/html/klastorin.html:using hierarchical cluster analysis. <EM>Operations Research</EM> <B>30</B>,1134&ndash;1147.
./ape.Rcheck/ape/latex/klastorin.tex:using hierarchical cluster analysis. \emph{Operations Research} \bold{30},1134--1147.
./do-install:## ash, cluster, ... fail to link on Solaris !!
./lme4/man/guPrenat.Rd:    \item{cluster}{a factor identifying the community}
./lme4/tests/guPrenat.R:                       random = ~ 1|cluster/mom,
./pan/man/ecme:        or cluster i;
./pan/man/ecme:        subject or cluster i (random effects); and
./pan/man/ecme:particular unit within a cluster.
./pan/man/ecme:vector of same length as y, giving the subject (or cluster)
./pan/man/ecme:of occ label the units within each cluster i, using the labels
./pan/man/pan:Imputation of multivariate panel or cluster data
./pan/man/pan:        data for subject or cluster i;
./pan/man/pan:        subject or cluster i (random effects); and
./pan/man/pan:subject-occasion, or to a single subject within a cluster.
./pan/man/pan:vector of length nrow(y) giving the subject (or cluster)
./pan/man/pan.bd:Imputation of multivariate panel or cluster data
./pan/man/pan.Rd:Imputation of multivariate panel or cluster data
./pan/man/pan.Rd:        data for subject or cluster i;
./pan/man/pan.Rd:        subject or cluster i (random effects); and
./pan/man/pan.Rd:subject-occasion, or to a single subject within a cluster.
./pan/man/pan.Rd:vector of length nrow(y) giving the subject (or cluster)
./pan/man/pan.bd.Rd:Imputation of multivariate panel or cluster data
./pan/man/ecme.Rd:        or cluster i;
./pan/man/ecme.Rd:        subject or cluster i (random effects); and
./pan/man/ecme.Rd:particular unit within a cluster.
./pan/man/ecme.Rd:vector of same length as y, giving the subject (or cluster)
./pan/man/ecme.Rd:of occ label the units within each cluster i, using the labels
./lmm/man/fastmcmc.lmm:particular unit within a cluster.
./lmm/man/fastmcmc.lmm:vector of same length as y, giving the subject (or cluster)
./lmm/man/fastmcmc.lmm:of occ label the units within each cluster i, using the labels
./lmm/man/fastmcmc.lmm:		or cluster i;
./lmm/man/fastmcmc.lmm:		subject or cluster i (random effects); and
./lmm/man/fastml.lmm:particular unit within a cluster.
./lmm/man/fastml.lmm:vector of same length as y, giving the subject (or cluster)
./lmm/man/fastml.lmm:of occ label the units within each cluster i, using the labels
./lmm/man/fastml.lmm:		or cluster i;
./lmm/man/fastml.lmm:		subject or cluster i (random effects); and
./lmm/man/mgibbs.lmm:particular unit within a cluster.
./lmm/man/mgibbs.lmm:vector of same length as y, giving the subject (or cluster)
./lmm/man/mgibbs.lmm:of occ label the units within each cluster i, using the labels
./lmm/man/mgibbs.lmm:		or cluster i;
./lmm/man/mgibbs.lmm:		subject or cluster i (random effects); and
./lmm/man/fastrml.lmm:particular unit within a cluster.
./lmm/man/fastrml.lmm:vector of same length as y, giving the subject (or cluster)
./lmm/man/fastrml.lmm:of occ label the units within each cluster i, using the labels
./lmm/man/fastrml.lmm:		or cluster i;
./lmm/man/fastrml.lmm:		subject or cluster i (random effects); and
./lmm/man/ecmerml.lmm:particular unit within a cluster.
./lmm/man/ecmerml.lmm:vector of same length as y, giving the subject (or cluster)
./lmm/man/ecmerml.lmm:of occ label the units within each cluster i, using the labels
./lmm/man/ecmerml.lmm:		or cluster i;
./lmm/man/ecmerml.lmm:		subject or cluster i (random effects); and
./lmm/man/ecmeml.lmm:particular unit within a cluster.
./lmm/man/ecmeml.lmm:vector of same length as y, giving the subject (or cluster)
./lmm/man/ecmeml.lmm:of occ label the units within each cluster i, using the labels
./lmm/man/ecmeml.lmm:		or cluster i;
./lmm/man/ecmeml.lmm:		subject or cluster i (random effects); and
./lmm/man/fastmode.lmm.Rd:particular unit within a cluster.
./lmm/man/fastmode.lmm.Rd:vector of same length as y, giving the subject (or cluster)
./lmm/man/fastmcmc.lmm.Rd:particular unit within a cluster.
./lmm/man/fastmcmc.lmm.Rd:vector of same length as y, giving the subject (or cluster)
./lmm/man/fastmcmc.lmm.Rd:		or cluster i;
./lmm/man/fastmcmc.lmm.Rd:		subject or cluster i (random effects); and
./lmm/man/ecmeml.lmm.Rd:particular unit within a cluster.
./lmm/man/ecmeml.lmm.Rd:vector of same length as y, giving the subject (or cluster)
./lmm/man/ecmeml.lmm.Rd:		or cluster i;
./lmm/man/ecmeml.lmm.Rd:		subject or cluster i (random effects); and
./lmm/man/ecmerml.lmm.Rd:particular unit within a cluster.
./lmm/man/ecmerml.lmm.Rd:vector of same length as y, giving the subject (or cluster)
./lmm/man/ecmerml.lmm.Rd:		or cluster i;
./lmm/man/ecmerml.lmm.Rd:		subject or cluster i (random effects); and
./lmm/man/fastml.lmm.Rd:particular unit within a cluster.
./lmm/man/fastml.lmm.Rd:vector of same length as y, giving the subject (or cluster)
./lmm/man/fastml.lmm.Rd:		or cluster i;
./lmm/man/fastml.lmm.Rd:		subject or cluster i (random effects); and
./lmm/man/fastrml.lmm.Rd:particular unit within a cluster.
./lmm/man/fastrml.lmm.Rd:vector of same length as y, giving the subject (or cluster)
./lmm/man/fastrml.lmm.Rd:		or cluster i;
./lmm/man/fastrml.lmm.Rd:		subject or cluster i (random effects); and
./lmm/man/mgibbs.lmm.Rd:particular unit within a cluster.
./lmm/man/mgibbs.lmm.Rd:vector of same length as y, giving the subject (or cluster)
./lmm/man/mgibbs.lmm.Rd:		or cluster i;
./lmm/man/mgibbs.lmm.Rd:		subject or cluster i (random effects); and
./ape/Changes:      "hclust" cluster objects and vice versa (see the help page of
./ape/man/klastorin.Rd:   using hierarchical cluster analysis. \emph{Operations Research} \bold{30},1134--1147.
./ipred/man/sbrier.Rd:# and mean gene expression in the first cluster as predictors
./ipred/man/DLBCL.Rd:    \item{MGEc.1}{mean gene expression in cluster 1.}
./ipred/man/DLBCL.Rd:    \item{MGEc.2}{mean gene expression in cluster 2.}
./ipred/man/DLBCL.Rd:    \item{MGEc.3}{mean gene expression in cluster 3.}
./ipred/man/DLBCL.Rd:    \item{MGEc.4}{mean gene expression in cluster 4.}
./ipred/man/DLBCL.Rd:    \item{MGEc.5}{mean gene expression in cluster 5.}
./ipred/man/DLBCL.Rd:    \item{MGEc.6}{mean gene expression in cluster 6.}
./ipred/man/DLBCL.Rd:    \item{MGEc.7}{mean gene expression in cluster 7.}
./ipred/man/DLBCL.Rd:    \item{MGEc.8}{mean gene expression in cluster 8.}
./ipred/man/DLBCL.Rd:    \item{MGEc.9}{mean gene expression in cluster 9.}
./ipred/man/DLBCL.Rd:    \item{MGEc.10}{mean gene expression in cluster 10.}
./ipred/man/DLBCL.Rd:linkage hierarchical cluster analysis (Hothorn et al., 2002).
./ipred/tests/ipred-tests.R:# and mean gene expression in the first cluster as predictors
./ipred/tests/ipred-tests.Rout.save:> # and mean gene expression in the first cluster as predictors
./list:cluster
./spdep/man/localG.Rd:of a local cluster of high values of the variable being analysed, very
./spdep/man/localG.Rd:low relative values a similar cluster of low values. For inference,
./covRobust/R/cov.nnve.R:		# z will be the classifications. 1= in cluster. 0= in noise.
